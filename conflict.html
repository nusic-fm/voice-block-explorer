<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>AI Voice Agent Launchpad</title>
    <style>
        #ui {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            max-width: max-content;
            color: #00ffff;
            background: rgba(10, 10, 18, 0.9);
            padding: 0.8rem 1.2rem;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            z-index: 2;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        :root {
            --space-black: #0a0a0f;
            --neon-teal: rgba(0, 255, 255, 0.8);
            --glass-panel: rgba(10, 10, 18, 0.96);
            --subtle-border: rgba(0, 255, 255, 0.2);
        }

        body {
            background: var(--space-black);
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            color: #e0e0e0;
            user-select: none; /* Prevent text selection globally */
        }

        .metadata-panel {
            position: fixed;
            background: var(--glass-panel);
            border: 1px solid var(--subtle-border);
            border-radius: 12px;
            padding: 1.5rem;
            padding-top: 2.5rem;
            width: 360px;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: grid;
            gap: 1rem;
            border-image: linear-gradient(
                145deg,
                rgba(0, 255, 255, 0.15),
                rgba(0, 255, 255, 0.05)
            ) 1;
            z-index: 35;
        }

        .metadata-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .audio-player-container {
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 0.5rem 0;
        }

        audio {
            width: 100%;
            filter: drop-shadow(0 2px 4px rgba(0, 255, 255, 0.1));
        }

        audio::-webkit-media-controls-panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
        }

        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: grid;
            place-items: center;
            transition: all 0.3s ease;
            z-index: 1001;
        }

        .close-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--neon-teal);
            transform: rotate(90deg);
        }

        .node-label {
            position: fixed;
            font-size: 1.8em;
            pointer-events: none !important; /* Ensure labels don't interfere */
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            z-index: 1000;
            color: #00ffff;
            user-select: none;
        }

        .audio-node {
            background: radial-gradient(
                circle at center,
                rgba(0, 255, 255, 0.15) 0%,
                transparent 70%
            );
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(0, 255, 255, 0.1);
        }

        .audio-node:hover {
            background: radial-gradient(
                circle at center,
                rgba(0, 255, 255, 0.25) 0%,
                transparent 70%
            );
            transform: scale(1.1);
        }

        .youtube-embed {
            width: 100%;
            aspect-ratio: 16/9;
            border: none;
            border-radius: 8px;
            margin-top: 1rem;
            background: #000;
        }

        .side-panel {
            position: fixed;
            top: 0;
            height: 100vh;
            width: 300px;
            background: var(--glass-panel);
            backdrop-filter: blur(20px);
            padding: 1.5rem;
            color: var(--neon-teal);
            overflow-y: auto;
            z-index: 30;
        }

        .left-panel {
            left: 0;
            border-right: 1px solid var(--subtle-border);
        }

        .right-panel {
            right: 0;
            border-left: 1px solid var(--subtle-border);
        }

        .analytics-item {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.1);
            box-sizing: border-box;
        }

        .chart-container {
            width: 100%;
            height: 200px;
            margin: 0.5rem 0;
            position: relative;
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 4px;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            box-sizing: border-box;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 3rem);
        }

        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
            z-index: 20;
            position: relative;
            user-select: text; /* Allow text selection only in specific areas */
        }

        .message {
            margin-bottom: 1rem;
            padding: 0.8rem;
            border-radius: 8px;
            max-width: 85%;
        }

        .user-message {
            background: rgba(0, 255, 255, 0.1);
            margin-left: auto;
        }

        .bot-message {
            background: rgba(0, 0, 0, 0.3);
            margin-right: auto;
        }

        .chat-input {
            position: relative;
            z-index: 31;
            display: flex;
            gap: 0.5rem;
            user-select: text; /* Allow text selection only in specific areas */
        }

        .chat-input input {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.2);
            padding: 0.8rem;
            border-radius: 4px;
            color: var(--neon-teal);
        }

        .chat-input button {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--neon-teal);
            color: var(--neon-teal);
            padding: 0.8rem 1.2rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .chat-input button:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        .visualization-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: all;
            user-select: none;
            cursor: default;
        }

        .visualization-container.visible {
            opacity: 1;
        }

        canvas {
            position: absolute !important;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            cursor: pointer !important; /* Force pointer cursor */
        }

        .face-container {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 500px;
            z-index: 1;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .face-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.3s ease;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.9);
        }

        .particle.tentacle {
            width: 5px;
            height: 5px;
            background: rgba(0, 255, 255, 0.9);
            box-shadow: 0 0 40px rgba(0, 255, 255, 1);
        }

        .particle.fractal {
            width: 3px;
            height: 3px;
            background: rgba(0, 255, 255, 1);
            box-shadow: 0 0 35px rgba(0, 255, 255, 1);
        }

        .particle.energy {
            width: 2px;
            height: 2px;
            background: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.9);
        }

        .face-container::before {
            content: '';
            position: absolute;
            top: -100%;
            left: -100%;
            width: 300%;
            height: 300%;
            background: radial-gradient(
                circle at center,
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.1) 30%,
                rgba(0, 0, 0, 0.2) 60%,
                rgba(0, 0, 0, 0.3) 80%
            );
            z-index: -1;
        }

        @keyframes tentacleFlow {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        @keyframes fractalGlow {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.6;
            }
            50% { 
                transform: scale(1.2);
                opacity: 0.3;
            }
        }

        @keyframes energyPulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.3;
            }
            50% { 
                transform: scale(1.5);
                opacity: 0.1;
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        @keyframes eyePulse {
            0%, 100% { 
                opacity: 0.8;
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.9);
            }
            50% { 
                opacity: 1;
                box-shadow: 0 0 30px rgba(0, 255, 255, 1);
            }
        }

        @keyframes eyeGlow {
            0%, 100% { box-shadow: 0 0 25px rgba(0, 255, 255, 1); }
            50% { box-shadow: 0 0 35px rgba(0, 255, 255, 1); }
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(1px, 1px); }
            50% { transform: translate(-1px, 0.5px); }
            75% { transform: translate(0.5px, -1px); }
        }

        @keyframes circuitFlow {
            0% { opacity: 0.3; }
            50% { opacity: 0.8; }
            100% { opacity: 0.3; }
        }

        .kraken-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            overflow: hidden;
        }

        .tentacle-particle {
            position: absolute;
            background: rgba(0, 255, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            transform-origin: center;
        }

        .branch-particle {
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }

        .float-particle {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .center-orb {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 20px rgba(255, 255, 255, 0.8),
                0 0 40px rgba(255, 255, 255, 0.6),
                0 0 60px rgba(255, 255, 255, 0.4);
            animation: orbPulse 4s ease-in-out infinite;
        }

        @keyframes orbPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 
                    0 0 20px rgba(255, 255, 255, 0.8),
                    0 0 40px rgba(255, 255, 255, 0.6),
                    0 0 60px rgba(255, 255, 255, 0.4);
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.2);
                box-shadow: 
                    0 0 30px rgba(255, 255, 255, 0.9),
                    0 0 60px rgba(255, 255, 255, 0.7),
                    0 0 90px rgba(255, 255, 255, 0.5);
            }
        }

        .choice-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--neon-teal);
            color: var(--neon-teal);
            padding: 0.5rem 1rem;
            margin: 0.3rem 0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            text-align: left;
        }

        .choice-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .video-grid {
            position: fixed;
            left: 350px;
            right: 350px;
            top: 50%;
            transform: translateY(-50%);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
            padding: 3rem;
            z-index: 35;
            max-height: 85vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--subtle-border);
        }

        .audio-clips-grid {
            position: fixed;
            left: 350px;
            right: 350px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            justify-content: center;
            gap: 3rem;
            padding: 3rem;
            z-index: 35;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--subtle-border);
        }

        .audio-clip-option {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--neon-teal);
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 200px;
        }

        .audio-clip-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.8);
        }

        .video-option {
            width: 100%;
            max-width: 280px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--neon-teal);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
        }

        .video-preview {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            overflow: hidden;
            background: #000;
            border-radius: 8px 8px 0 0;
        }

        .video-thumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }

        .video-duration {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .video-info {
            padding: 1rem;
            color: var(--neon-teal);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .video-title {
            font-size: 1.1rem;
            font-weight: 500;
        }

        .video-description {
            font-size: 0.9rem;
            opacity: 0.8;
            line-height: 1.4;
        }

        .video-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.8);
        }

        .video-option:hover .video-thumbnail {
            transform: scale(1.05);
        }

        .loading-percentage {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: var(--neon-teal);
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            z-index: 11;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .play-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid var(--neon-teal);
            color: var(--neon-teal);
            font-size: 32px;
            cursor: pointer;
            margin: 1rem auto;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-button:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .clip-label {
            color: var(--neon-teal);
            margin-top: 1.5rem;
            font-size: 1.2rem;
            font-weight: 500;
        }

        .side-panel {
            z-index: 30;
        }

        /* Add custom scrollbar for better visibility */
        .video-grid::-webkit-scrollbar {
            width: 8px;
            margin-right: 4px;
        }

        .video-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin: 4px;
        }

        .video-grid::-webkit-scrollbar-thumb {
            background: var(--neon-teal);
            border-radius: 4px;
        }

        .audio-clip-option audio {
            display: none;
        }

        /* Allow text selection only in specific areas */
        .chat-messages, 
        .chat-input input,
        .metadata-panel {
            user-select: text;
        }
    </style>
</head>
<body>
    <div class="face-container">
        <div class="face">
            <div class="face-part eye eye-left"></div>
            <div class="face-part eye eye-right"></div>
            <div class="glitch-overlay"></div>
        </div>
    </div>
    <div class="visualization-container"></div>
    <div id="ui">Loading...</div>
    <template id="metadata-template">
        <div class="metadata-panel">
            <button class="close-btn">×</button>
            <div class="metadata-content">
                <h3 class="title"></h3>
                <div class="audio-player-container">
                    <audio class="player" controls></audio>
                </div>
                <iframe class="youtube-embed" 
                        allowfullscreen
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture">
                </iframe>
                <table>
                    <tr><td>Duration:</td><td class="duration"></td></tr>
                </table>
            </div>
        </div>
    </template>

    <div class="side-panel left-panel">
        <h2>Analytics</h2>
        <div class="analytics-item">
            <h3>Audio Distribution</h3>
            <div class="chart-container" id="distributionChart">
                <!-- Chart will be rendered here -->
            </div>
            <p>Total Samples: <span id="totalSamples">0</span></p>
        </div>
        <div class="analytics-item">
            <h3>Duration Stats</h3>
            <p>Average Duration: <span id="avgDuration">0:00</span></p>
            <p>Longest Sample: <span id="maxDuration">0:00</span></p>
            <p>Shortest Sample: <span id="minDuration">0:00</span></p>
        </div>
        <div class="analytics-item">
            <h3>Categories</h3>
            <div id="categories">
                <!-- Categories will be populated here -->
            </div>
        </div>
    </div>

    <div class="side-panel right-panel">
        <div class="chat-container">
            <h2>Voice Agent Launcher</h2>
            <div class="chat-messages" id="chatMessages">
                <div class="message bot-message">
                    Welcome! Let's launch your AI voice agent. What's the name of the voice you wanna use?
                </div>
            </div>
            <div class="chat-input">
                <input type="text" id="chatInput" placeholder="Type your message...">
                <button onclick="sendMessage()">Send</button>
            </div>
        </div>
    </div>

    <div class="kraken-container"></div>

    <div class="loading-percentage">0%</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
let scene, camera, renderer, controls;
let audioNodes = [];
let currentPanel = null;
let audioContextInitialized = false;
let visualizationInitialized = false;


class AudioNode {
    constructor(position, data, index, totalNodes) {
        this.data = data;
        this.mesh = new THREE.Mesh(
            new THREE.CircleGeometry(0.4, 32),
            new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0,
                depthTest: false,  // Disable depth testing
                depthWrite: false, // Disable depth writing
                side: THREE.DoubleSide,
                renderOrder: 1     // Ensure it renders on top
            })
        );
        
        // Add a larger invisible collision mesh for better click detection
        this.clickMesh = new THREE.Mesh(
            new THREE.SphereGeometry(1, 8, 8),
            new THREE.MeshBasicMaterial({
                visible: false,
                depthTest: false,
                depthWrite: false
            })
        );
        this.clickMesh.position.copy(position);
        this.clickMesh.userData = this.mesh.userData;
        
        this.mesh.lookAt(new THREE.Vector3(0, 0, 1));
        
        if (data && data.source) {
            try {
                const videoId = this.extractVideoId(data.source);
                // Look specifically for t=XXs format
                const timeMatch = data.source.match(/[?&]t=(\d+)s?/);
                const startTime = timeMatch ? parseInt(timeMatch[1]) : 0;
                
                // Construct embed URL with start time if present
                this.embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1${startTime ? '&start=' + startTime : ''}`;
                console.log('Video will start at:', startTime, 'seconds');
                console.log('Final embed URL:', this.embedUrl);
            } catch (error) {
                console.error('Error processing YouTube URL:', error);
            }
        }
        
        // Start at center
        this.mesh.position.set(0, 0, 0);
        this.targetPosition = position.clone();
        this.animationProgress = 0;
        this.randomOffset = new THREE.Vector3(
            (Math.random() - 0.5) * 0.8,
            (Math.random() - 0.5) * 0.8,
            (Math.random() - 0.5) * 0.8
        );

        // Stagger the start time based on index
        this.startDelay = (index / totalNodes) * 0.5; // 0.5 seconds total stagger
        this.hasStarted = false;
        this.elapsedTime = 0;
        
        // Create label with 0 opacity
        this.label = document.createElement('div');
        this.label.className = 'node-label';
        this.label.textContent = data.emoji;
        this.label.style.opacity = '0';
        document.body.appendChild(this.label);

        // Add click handling
        this.mesh.userData = {
            type: 'audioNode',
            metadata: data
        };
    }

    update(deltaTime) {
        const ANIMATION_SPEED = 1.2;
        this.elapsedTime += deltaTime;

        if (this.elapsedTime < this.startDelay) {
            return;
        }

        if (!this.hasStarted) {
            this.hasStarted = true;
            this.animationProgress = 0;
        }
        
        if (this.animationProgress < 1) {
            this.animationProgress += deltaTime * ANIMATION_SPEED;
            this.animationProgress = Math.min(this.animationProgress, 1);
            
            const t = this.animationProgress;
            const eased = t < 0.5 
                ? 4 * t * t 
                : 1 + Math.sin((t - 0.5) * Math.PI) * Math.exp(-(t - 0.5) * 2.5) * 0.35;
            
            const progress = eased;
            const overshotPosition = this.targetPosition.clone().add(
                this.targetPosition.clone().normalize().multiplyScalar(3.5 * (1 - progress))
            );
            
            const currentOffset = this.randomOffset.clone().multiplyScalar(1 - progress);
            
            this.mesh.position.lerpVectors(
                new THREE.Vector3(0, 0, 0),
                overshotPosition.add(currentOffset),
                progress
            );

            // Make circle continuously face camera
            this.mesh.lookAt(camera.position);
            
            // Adjust opacity
            const fadeProgress = Math.min(this.animationProgress * 2, 1);
            this.mesh.material.opacity = 0.25 * fadeProgress;  // Reduced opacity for subtler effect
            this.label.style.opacity = fadeProgress;
        }

        // Update clickMesh position to match visible mesh
        this.clickMesh.position.copy(this.mesh.position);
        this.clickMesh.lookAt(camera.position);
    }

    updateLabelPosition() {
        const vector = this.mesh.position.clone().project(camera);
        const container = document.querySelector('.visualization-container');
        const rect = container.getBoundingClientRect();
        
        this.label.style.left = `${rect.left + (vector.x + 1) * rect.width / 2}px`;
        this.label.style.top = `${rect.top + (-vector.y + 1) * rect.height / 2}px`;
    }

    extractVideoId(url) {
        // Handle both youtube.com and youtu.be formats
        const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
        const match = url.match(regExp);
        return (match && match[7].length === 11) ? match[7] : null;
    }

    onClick() {
        if (this.mesh.userData.metadata) {
            showMetadataPanel(this.mesh.userData.metadata);
        }
    }
}

async function init() {
    scene = new THREE.Scene();
    
    // Get the visualization container dimensions
    const container = document.querySelector('.visualization-container');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    camera = new THREE.PerspectiveCamera(75, containerWidth/containerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true 
    });
    
    renderer.setSize(containerWidth, containerHeight);
    container.appendChild(renderer.domElement);
    
    try {
        const response = await fetch('audio/metadata.json');
        const audioFiles = await response.json();
        
        const nodeCount = audioFiles.length;
        // Adjust radius for better distribution
        const radius = 18 + Math.cbrt(nodeCount) * 1.2;

        audioFiles.forEach((file, index) => {
            const phi = Math.acos(-1 + (2 * index)/nodeCount);
            const theta = Math.sqrt(nodeCount * Math.PI) * phi;
            
            const position = new THREE.Vector3(
                Math.cos(theta) * radius * Math.sin(phi),
                Math.sin(theta) * radius * Math.sin(phi),
                Math.cos(phi) * radius
            );

            const node = new AudioNode(position, file, index, nodeCount);
            scene.add(node.mesh);
            audioNodes.push(node);
        });

        document.getElementById('ui').textContent = `Audio Dataset Prepared for Blockchain Instantiation`;
        // Make visualization visible
        document.querySelector('.visualization-container').classList.add('visible');

    } catch (error) {
        document.getElementById('ui').textContent = `Error: ${error.message}`;
        return;
    }

    // Adjust camera and controls
    camera.position.z = 40;
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;
    controls.minDistance = 30;
    controls.maxDistance = 80;
    controls.enabled = true;  // Make sure controls are enabled

    // Add raycaster for clicking nodes
    const raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 1;
    const mouse = new THREE.Vector2();
    
    renderer.domElement.addEventListener('click', (event) => {
        // Calculate mouse position in normalized device coordinates
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        // Update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // Calculate objects intersecting the picking ray
        const intersects = raycaster.intersectObjects([
            ...audioNodes.map(node => node.mesh),
            ...audioNodes.map(node => node.clickMesh)
        ]);

        if (intersects.length > 0) {
            const node = audioNodes.find(n => 
                n.mesh === intersects[0].object || 
                n.clickMesh === intersects[0].object
            );
            if (node && node.data) {
                showMetadataPanel(node.data, event);
            }
        }
    });

    animate();
}

function showMetadataPanel(metadata, event) {
    if (currentPanel) {
        currentPanel.remove();
    }

    const template = document.getElementById('metadata-template');
    const panel = template.content.cloneNode(true).children[0];
    
    // Fill in metadata
    panel.querySelector('.title').textContent = metadata.name;
    panel.querySelector('.duration').textContent = metadata.duration;
    
    // Set up audio player
    const player = panel.querySelector('.player');
    player.src = `audio/${metadata.filename}`;
    
    // Set up YouTube embed
    const embed = panel.querySelector('.youtube-embed');
    if (metadata.source) {
        const videoId = extractVideoId(metadata.source);
        if (videoId) {
            embed.src = `https://www.youtube.com/embed/${videoId}`;
            embed.style.display = 'block';
        } else {
            embed.style.display = 'none';
        }
    } else {
        embed.style.display = 'none';
    }
    
    // Position panel near click
    const padding = 20;
    const maxRight = window.innerWidth - panel.offsetWidth - padding;
    const maxBottom = window.innerHeight - panel.offsetHeight - padding;
    
    panel.style.position = 'fixed';
    panel.style.left = `${Math.min(event.clientX, maxRight)}px`;
    panel.style.top = `${Math.min(event.clientY, maxBottom)}px`;
    
    // Set up close button
    panel.querySelector('.close-btn').addEventListener('click', () => {
        panel.remove();
        currentPanel = null;
    });
    
    document.body.appendChild(panel);
    currentPanel = panel;
}

function extractVideoId(url) {
    const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
    const match = url.match(regExp);
    return (match && match[7].length === 11) ? match[7] : null;
}

function animate() {
    requestAnimationFrame(animate);
    
    const time = performance.now();
    const deltaTime = (time - (animate.lastTime || time)) / 1000;
    animate.lastTime = time;

    audioNodes.forEach(node => {
        node.update(deltaTime);
        node.updateLabelPosition();
    });
    
    controls.update();  // This is important for controls to work
    renderer.render(scene, camera);
}

window.onresize = () => {
    const container = document.querySelector('.visualization-container');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    camera.aspect = containerWidth / containerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(containerWidth, containerHeight);
};

// Dummy analytics data
function updateAnalytics(audioFiles) {
    document.getElementById('totalSamples').textContent = audioFiles.length;
    
    // Calculate duration stats
    const durations = audioFiles.map(file => {
        const [mins, secs] = file.duration.split(':').map(Number);
        return mins * 60 + secs;
    });
    
    const avgSeconds = durations.reduce((a, b) => a + b, 0) / durations.length;
    const maxSeconds = Math.max(...durations);
    const minSeconds = Math.min(...durations);
    
    document.getElementById('avgDuration').textContent = formatDuration(avgSeconds);
    document.getElementById('maxDuration').textContent = formatDuration(maxSeconds);
    document.getElementById('minDuration').textContent = formatDuration(minSeconds);
    
    // Create dummy distribution chart
    const ctx = document.createElement('canvas');
    document.getElementById('distributionChart').appendChild(ctx);
    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['0-30s', '30-60s', '60-90s', '90-120s', '120s+'],
            datasets: [{
                label: 'Duration Distribution',
                data: [4, 8, 15, 7, 3],
                backgroundColor: 'rgba(0, 255, 255, 0.2)',
                borderColor: 'rgba(0, 255, 255, 0.8)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    labels: {
                        color: 'rgba(0, 255, 255, 0.8)'
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(0, 255, 255, 0.1)'
                    },
                    ticks: {
                        color: 'rgba(0, 255, 255, 0.8)'
                    }
                },
                x: {
                    grid: {
                        color: 'rgba(0, 255, 255, 0.1)'
                    },
                    ticks: {
                        color: 'rgba(0, 255, 255, 0.8)'
                    }
                }
            }
        }
    });
}

function formatDuration(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Chat functionality
function sendMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    if (!message) return;
    
    const chatMessages = document.getElementById('chatMessages');
    
    // Check if message is a YouTube URL
    if (message.includes('youtube.com') || message.includes('youtu.be')) {
        // Handle direct YouTube URL input
        const botMsg = document.createElement('div');
        botMsg.className = 'message bot-message';
        botMsg.textContent = 'Great! Let me process that video for you...';
        chatMessages.appendChild(botMsg);
        
        krakenEffect.startLoading(() => {
            krakenEffect.startTransition();
            visualizationInitialized = true;
        });
    } else {
        // Start first loading animation without initial message
        krakenEffect.startLoading(() => {
            // Show message and videos after loading
            const botMsg = document.createElement('div');
            botMsg.className = 'message bot-message';
            botMsg.textContent = `I found several versions of "${message}" are any of these correct? Please select one, or feel free to paste a YouTube url directly into chat`;
            chatMessages.appendChild(botMsg);
            
            // Create video grid
            const videoGrid = document.createElement('div');
            videoGrid.className = 'video-grid';
            
            // Example video options with better formatting
            const videoOptions = [
                { 
                    id: 'dQw4w9WgXcQ', 
                    title: 'Option 1 - Studio Version', 
                    duration: '3:32',
                    description: 'Official music video'
                },
                { 
                    id: 'oHg5SJYRHA0', 
                    title: 'Option 2 - Live Performance', 
                    duration: '4:15',
                    description: 'Live at Madison Square Garden'
                },
                { 
                    id: 'xvFZjo5PgG0', 
                    title: 'Option 3 - Acoustic Version', 
                    duration: '3:45',
                    description: 'Acoustic performance'
                },
                { 
                    id: 'V-_O7nl0Ii0', 
                    title: 'Option 4 - Music Video', 
                    duration: '3:58',
                    description: 'Official music video'
                },
                { 
                    id: 'j5a0jTc9S10', 
                    title: 'Option 5 - Cover Version', 
                    duration: '3:21',
                    description: 'Cover version'
                }
            ];

            videoOptions.forEach(video => {
                const option = document.createElement('div');
                option.className = 'video-option';
                option.innerHTML = `
                    <div class="video-preview">
                        <img class="video-thumbnail" 
                            src="https://i.ytimg.com/vi/${video.id}/hqdefault.jpg" 
                            alt="${video.title}">
                        <div class="video-duration">${video.duration}</div>
                    </div>
                    <div class="video-info">
                        <div class="video-title">${video.title}</div>
                        <div class="video-description">${video.description}</div>
                    </div>
                `;

                option.addEventListener('click', () => {
                    // Remove video grid
                    videoGrid.remove();
                    
                    // Add selection confirmation message
                    const selectionMsg = document.createElement('div');
                    selectionMsg.className = 'message bot-message';
                    selectionMsg.textContent = `Processing your selection...`;
                    chatMessages.appendChild(selectionMsg);
                    
                    // Start first loading animation
                    krakenEffect.startLoading(() => {
                        // Add voice selection message
                        const voiceMsg = document.createElement('div');
                        voiceMsg.className = 'message bot-message';
                        voiceMsg.textContent = `There was more than one voice in that video, could you listen to these clips and select which voice it is you wish your agent to have?`;
                        chatMessages.appendChild(voiceMsg);
                        
                        // Create audio clips grid
                        const audioGrid = document.createElement('div');
                        audioGrid.className = 'audio-clips-grid';
                        
                        // Example audio clips - replace with actual clips from the video
                        const audioClips = [
                            { id: 1, label: 'Voice 1', url: 'audio/sample1.mp3' },
                            { id: 2, label: 'Voice 2', url: 'audio/sample2.mp3' },
                            { id: 3, label: 'Voice 3', url: 'audio/sample3.mp3' }
                        ];

                        audioClips.forEach(clip => {
                            const clipOption = document.createElement('div');
                            clipOption.className = 'audio-clip-option';
                            clipOption.innerHTML = `
                                <button class="play-button">▶</button>
                                <div class="clip-label">${clip.label}</div>
                                <audio src="${clip.url}" preload="auto"></audio>
                            `;

                            const playButton = clipOption.querySelector('.play-button');
                            const audio = clipOption.querySelector('audio');
                            
                            playButton.addEventListener('click', (e) => {
                                e.stopPropagation();
                                
                                // Stop all other audio clips
                                document.querySelectorAll('.audio-clip-option audio').forEach(a => {
                                    if (a !== audio) {
                                        a.pause();
                                        a.currentTime = 0;
                                        a.closest('.audio-clip-option').querySelector('.play-button').textContent = '▶';
                                    }
                                });
                                
                                // Toggle play/pause
                                if (audio.paused) {
                                    audio.play();
                                    playButton.textContent = '⏸';
                                } else {
                                    audio.pause();
                                    audio.currentTime = 0;
                                    playButton.textContent = '▶';
                                }
                            });

                            // Reset button when audio ends
                            audio.addEventListener('ended', () => {
                                playButton.textContent = '▶';
                            });

                            clipOption.addEventListener('click', () => {
                                // Remove audio grid
                                audioGrid.remove();
                                
                                // Add processing message
                                const processingMsg = document.createElement('div');
                                processingMsg.className = 'message bot-message';
                                processingMsg.textContent = `Processing your voice selection...`;
                                chatMessages.appendChild(processingMsg);
                                
                                // Final loading animation before vortex
                                krakenEffect.startLoading(() => {
                                    krakenEffect.startTransition();
                                    visualizationInitialized = true;
                                });
                            });

                            audioGrid.appendChild(clipOption);
                        });

                        document.body.appendChild(audioGrid);
                    });
                });

                videoGrid.appendChild(option);
            });

            document.body.appendChild(videoGrid);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        });
    }

    input.value = '';
}

// Add event listener for Enter key in chat input
document.getElementById('chatInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        sendMessage();
    }
});

// Modify the existing init() function to call updateAnalytics
const originalInit = init;
init = async function() {
    await originalInit();
    const response = await fetch('audio/metadata.json');
    const audioFiles = await response.json();
    updateAnalytics(audioFiles);
};

// init();  // Remove this line since we'll call it after first chat message

// Face particle system
class KrakenEffect {
    constructor() {
        this.container = document.querySelector('.kraken-container');
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;
        this.particles = [];
        this.time = 0;
        this.mouseX = this.centerX;
        this.mouseY = this.centerY;
        
        // Scale parameters based on screen size
        const screenSize = Math.min(this.width, this.height);
        const scaleFactor = Math.max(1, screenSize / 800); // Base scale on 800px reference
        
        this.numTentacles = 8;
        this.maxDepth = 3;
        this.floatingParticles = Math.floor(80 * scaleFactor);
        this.baseRadius = Math.min(400, 250 * scaleFactor); // Scale radius with screen
        this.branchLength = Math.min(500, 300 * scaleFactor); // Scale branch length
        
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / 30;
        this.mouseThrottle = 0;
        this.transformUpdates = new Map();
        
        this.transitioning = false;
        this.transitionProgress = 0;
        this.vortexStrength = 0;
        
        this.mode = 'normal'; // 'normal', 'loading', 'vortex'
        this.loadingProgress = 0;
        this.loadingParticles = [];
        
        // Add percentage display element
        this.percentageDisplay = document.createElement('div');
        this.percentageDisplay.className = 'loading-percentage';
        document.body.appendChild(this.percentageDisplay);
        
        this.init();
        
        // Bind the resize handler to this instance
        this.handleResize = this.handleResize.bind(this);
        window.addEventListener('resize', this.handleResize);
    }

    init() {
        this.bindEvents();
        this.createFractals();
        this.animate();
    }

    bindEvents() {
        let lastMouseMove = 0;
        window.addEventListener('mousemove', (e) => {
            const now = performance.now();
            if (now - lastMouseMove > 16) {
                this.mouseX = e.clientX;
                this.mouseY = e.clientY;
                lastMouseMove = now;
            }
        }, { passive: true });
    }

    createFractals() {
        for (let i = 0; i < this.numTentacles; i++) {
            const angle = (i / this.numTentacles) * Math.PI * 2;
            this.createBranch(
                this.centerX,
                this.centerY,
                this.branchLength,
                angle,
                0
            );
        }

        for (let i = 0; i < this.floatingParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * this.baseRadius;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            
            const particle = this.createParticle(x, y, 'float-particle', 2);
            particle.angle = angle;
            particle.radius = radius;
            particle.speed = 0.2 + Math.random() * 0.2;
        }
    }

    createBranch(startX, startY, length, angle, depth) {
        if (depth >= this.maxDepth) return;

        const segments = 10 - depth * 2;
        const segmentLength = length / segments;
        let currentX = startX;
        let currentY = startY;

        for (let i = 0; i < segments; i++) {
            const t = i / segments;
            const size = 3.5 * (1 - depth/this.maxDepth) * (1 - t * 0.5);
            
            const particle = this.createParticle(
                currentX,
                currentY,
                'branch-particle',
                size
            );

            Object.assign(particle, {
                baseX: currentX,
                baseY: currentY,
                angle,
                segment: t,
                depth
            });

            if (t > 0.2 && Math.random() < 0.5 - depth * 0.15) {
                const branchAngle = angle + (Math.random() - 0.5) * Math.PI * 1.2;
                this.createBranch(
                    currentX,
                    currentY,
                    length * 0.6,
                    branchAngle,
                    depth + 1
                );
            }

            currentX += Math.cos(angle) * segmentLength;
            currentY += Math.sin(angle) * segmentLength;
        }
    }

    animate = (timestamp) => {
        if (timestamp - this.lastFrameTime < this.frameInterval) {
            requestAnimationFrame(this.animate);
            return;
        }
        this.lastFrameTime = timestamp;

        this.time += 0.016;
        this.transformUpdates.clear();
        
        if (this.mode === 'loading') {
            const progress = Math.min(1, this.loadingProgress / 100);
            const activeAngle = progress * Math.PI * 2;
            
            this.particles.forEach(particle => {
                // Update assembly progress
                particle.assembleProgress = Math.min(1, particle.assembleProgress + particle.assembleSpeed);
                
                // Ease function for smooth assembly
                const ease = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                const assembleEased = ease(particle.assembleProgress);
                
                // Calculate current position
                const x = particle.startX + (particle.targetX - particle.startX) * assembleEased;
                const y = particle.startY + (particle.targetY - particle.startY) * assembleEased;
                
                // Add subtle orbital motion
                const orbitRadius = 2 * Math.sin(this.time * 2 + particle.angle * 3);
                const finalX = x + Math.cos(particle.angle) * orbitRadius;
                const finalY = y + Math.sin(particle.angle) * orbitRadius;
                
                // Highlight active progress
                let opacity = 0.3;
                if (particle.angle <= activeAngle) {
                    opacity = 0.8 + Math.sin(this.time * 4) * 0.2; // Pulsing effect
                }
                
                particle.element.style.opacity = opacity;
                particle.element.style.transform = `translate(${finalX}px, ${finalY}px) scale(${0.8 + Math.sin(this.time * 3 + particle.angle) * 0.2})`;
                
                // Store position for vortex transition
                particle.baseX = finalX;
                particle.baseY = finalY;
            });
        } else {
            if (this.transitioning) {
                this.transitionProgress += 0.025; // Even faster transition
                this.vortexStrength = Math.min(1, this.transitionProgress * 4); // More immediate force
            }
            
            this.particles.forEach(particle => {
                let x = particle.baseX;
                let y = particle.baseY;
                
                if (this.transitioning) {
                    const dx = x - this.centerX;
                    const dy = y - this.centerY;
                    const dist = Math.hypot(dx, dy);
                    const angle = Math.atan2(dy, dx);
                    
                    // Much stronger direct pull to center
                    const gravitationalPull = Math.max(0.2, (400 - dist) / 400) * this.vortexStrength * 4;
                    
                    // Minimal spiral effect
                    const angularVelocity = (1 + (400 - dist) / 400) * this.vortexStrength * 0.2;
                    
                    const newAngle = angle + angularVelocity * (particle.speed || 0.5);
                    
                    // More aggressive inward movement
                    const newDist = Math.max(5, dist - gravitationalPull * (20 + Math.random() * 5));
                    
                    x = this.centerX + Math.cos(newAngle) * newDist;
                    y = this.centerY + Math.sin(newAngle) * newDist;
                    
                    // Minimal turbulence
                    const turbulence = (400 - newDist) / 400 * 2 * this.vortexStrength;
                    x += Math.sin(this.time * 10 + dist) * turbulence;
                    y += Math.cos(this.time * 10 + dist) * turbulence;
                    
                    // Slight stretching towards center
                    const stretch = Math.min(1.2, (400 - newDist) / 400);
                    const radialStretch = `scaleX(${1 + stretch * this.vortexStrength}) scaleY(${1 / (1 + stretch * this.vortexStrength)})`;
                    
                    const opacity = Math.max(0, (newDist - 5) / 100);
                    particle.element.style.opacity = opacity;
                    
                    particle.element.style.transform = `translate(${x}px, ${y}px) rotate(${newAngle}rad) ${radialStretch}`;
                    
                    if (newDist < 5 || opacity <= 0) {
                        particle.element.remove();
                        return;
                    }
                    
                    particle.baseX = x;
                    particle.baseY = y;
                    
                } else {
                    // Normal animation code
                    if (particle.depth !== undefined) {
                        const wave = Math.sin(this.time * 2 + particle.segment * 5) * 
                            (20 - particle.depth * 5);
                        const wave2 = Math.cos(this.time + particle.segment * 3) * 
                            (15 - particle.depth * 4);
                        
                        x += Math.cos(particle.angle) * wave;
                        y += Math.sin(particle.angle) * wave2;
                    } else {
                        particle.angle += particle.speed * 0.02;
                        const radius = particle.radius * (1 + Math.sin(this.time) * 0.1);
                        x = this.centerX + Math.cos(particle.angle) * radius;
                        y = this.centerY + Math.sin(particle.angle) * radius;
                    }
                    
                    // Mouse interaction
                    const dx = this.mouseX - x;
                    const dy = this.mouseY - y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist < 150) {
                        const force = (1 - dist / 150) * 15;
                        x += (dx / dist) * force;
                        y += (dy / dist) * force;
                    }
                    
                    this.transformUpdates.set(
                        particle.element, 
                        `translate(${x}px, ${y}px)`
                    );
                }
            });
        }
        
        if (!this.transitioning) {
            this.transformUpdates.forEach((transform, element) => {
                element.style.transform = transform;
            });
        }
        
        requestAnimationFrame(this.animate);
    }

    createParticle(x, y, className, size = 2) {
        const particle = document.createElement('div');
        particle.className = `tentacle-particle ${className}`;
        particle.style.width = size + 'px';
        particle.style.height = size + 'px';
        this.container.appendChild(particle);
        
        const particleObj = { element: particle, x, y, baseX: x, baseY: y };
        this.particles.push(particleObj);
        return particleObj;
    }

    handleResize() {
        // Update dimensions
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;

        // Recalculate scale parameters
        const screenSize = Math.min(this.width, this.height);
        const scaleFactor = Math.max(1, screenSize / 800);
        
        // Update scaled values
        this.baseRadius = Math.min(400, 250 * scaleFactor);
        this.branchLength = Math.min(500, 300 * scaleFactor);

        // Clear existing particles
        this.particles.forEach(particle => {
            particle.element.remove();
        });
        this.particles = [];
        
        // Recreate the pattern with new dimensions
        this.createFractals();
    }

    // Add cleanup method to prevent memory leaks
    cleanup() {
        window.removeEventListener('resize', this.handleResize);
        this.particles.forEach(particle => {
            particle.element.remove();
        });
        this.particles = [];
        this.percentageDisplay.remove();
    }

    // Add transition method
    startTransition() {
        this.mode = 'normal';
        this.transitioning = true;
        this.transitionProgress = 0;
        this.vortexStrength = 0;
        
        // Hide percentage display before transition
        this.percentageDisplay.style.opacity = '0';
        
        setTimeout(() => {
            init();
            document.getElementById('ui').style.opacity = '1';
            
            // Add blockchain message
            const chatMessages = document.getElementById('chatMessages');
            const blockchainMsg = document.createElement('div');
            blockchainMsg.className = 'message bot-message';
            blockchainMsg.textContent = `Here is the immutable audio dataset for your voice agent, this is instantiated to the Base blockchain and your agent will mint one of these pieces of audio as an NFT every time it processes a Text To Speech (TTS) request...`;
            chatMessages.appendChild(blockchainMsg);
            
            // Add TTS prompt after a short delay
            setTimeout(() => {
                const ttsPrompt = document.createElement('div');
                ttsPrompt.className = 'message bot-message';
                ttsPrompt.textContent = `Why don't you try a TTS request for your agent right now?`;
                chatMessages.appendChild(ttsPrompt);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 1000); // 1 second delay between messages
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }, 800);
    }

    startLoading(onComplete) {
        this.mode = 'loading';
        this.loadingProgress = 0;
        
        // Show percentage display
        this.percentageDisplay.style.opacity = '1';
        this.percentageDisplay.textContent = '0%';
        
        // Calculate circle parameters
        const radius = Math.min(this.width, this.height) * 0.2;
        const totalParticles = this.particles.length;
        
        // Assign target positions more organically
        this.particles.forEach((particle, index) => {
            // Calculate final circle position
            const angle = (index / totalParticles) * Math.PI * 2;
            const targetX = this.centerX + Math.cos(angle) * radius;
            const targetY = this.centerY + Math.sin(angle) * radius;
            
            // Add some randomness to starting positions
            const randomRadius = radius * (1 + Math.random() * 0.5);
            const randomAngle = Math.random() * Math.PI * 2;
            const startX = this.centerX + Math.cos(randomAngle) * randomRadius;
            const startY = this.centerY + Math.sin(randomAngle) * randomRadius;
            
            Object.assign(particle, {
                targetX,
                targetY,
                startX,
                startY,
                angle,
                assembleProgress: 0,
                assembleSpeed: 0.01 + Math.random() * 0.02
            });
        });

        const loadingInterval = setInterval(() => {
            this.loadingProgress += 0.7;
            
            // Update percentage display
            const percentage = Math.min(100, Math.floor(this.loadingProgress));
            this.percentageDisplay.textContent = `${percentage}%`;
            
            if (this.loadingProgress >= 100) {
                clearInterval(loadingInterval);
                
                // Fade out percentage display
                this.percentageDisplay.style.opacity = '0';
                
                setTimeout(() => {
                    if (onComplete) onComplete();
                }, 500);
            }
        }, 30);
    }
}

const krakenEffect = new KrakenEffect();
</script>
</body>
</html>
