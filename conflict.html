<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>AI Voice Agent Launchpad</title>
    <style>
        #ui {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            max-width: max-content;
            color: #00ffff;
            background: rgba(10, 10, 18, 0.9);
            padding: 0.8rem 1.2rem;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            z-index: 2;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        :root {
            --space-black: #0a0a0f;
            --neon-teal: rgba(0, 255, 255, 0.8);
            --glass-panel: rgba(10, 10, 18, 0.96);
            --subtle-border: rgba(0, 255, 255, 0.2);
        }

        body {
            background: var(--space-black);
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            color: #e0e0e0;
        }

        .metadata-panel {
            position: fixed;
            background: var(--glass-panel);
            border: 1px solid var(--subtle-border);
            border-radius: 12px;
            padding: 1.5rem;
            padding-top: 2.5rem;
            width: 360px;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: grid;
            gap: 1rem;
            border-image: linear-gradient(
                145deg,
                rgba(0, 255, 255, 0.15),
                rgba(0, 255, 255, 0.05)
            ) 1;
        }

        .metadata-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .audio-player-container {
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 0.5rem 0;
        }

        audio {
            width: 100%;
            filter: drop-shadow(0 2px 4px rgba(0, 255, 255, 0.1));
        }

        audio::-webkit-media-controls-panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
        }

        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: grid;
            place-items: center;
            transition: all 0.3s ease;
            z-index: 1001;
        }

        .close-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--neon-teal);
            transform: rotate(90deg);
        }

        .node-label {
            position: fixed;
            font-size: 1.8em;
            pointer-events: none;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            z-index: 1000;
            color: #00ffff;
        }

        .audio-node {
            background: radial-gradient(
                circle at center,
                rgba(0, 255, 255, 0.15) 0%,
                transparent 70%
            );
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(0, 255, 255, 0.1);
        }

        .audio-node:hover {
            background: radial-gradient(
                circle at center,
                rgba(0, 255, 255, 0.25) 0%,
                transparent 70%
            );
            transform: scale(1.1);
        }

        .youtube-embed {
            width: 100%;
            aspect-ratio: 16/9;
            border: none;
            border-radius: 8px;
            margin-top: 1rem;
            background: #000;
        }

        .side-panel {
            position: fixed;
            top: 0;
            height: 100vh;
            width: 300px;
            background: var(--glass-panel);
            backdrop-filter: blur(20px);
            padding: 1.5rem;
            color: var(--neon-teal);
            overflow-y: auto;
            z-index: 1;
        }

        .left-panel {
            left: 0;
            border-right: 1px solid var(--subtle-border);
        }

        .right-panel {
            right: 0;
            border-left: 1px solid var(--subtle-border);
        }

        .analytics-item {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.1);
        }

        .chart-container {
            width: 100%;
            height: 200px;
            margin: 1rem 0;
            position: relative;
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 4px;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 3rem);
        }

        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
        }

        .message {
            margin-bottom: 1rem;
            padding: 0.8rem;
            border-radius: 8px;
            max-width: 85%;
        }

        .user-message {
            background: rgba(0, 255, 255, 0.1);
            margin-left: auto;
        }

        .bot-message {
            background: rgba(0, 0, 0, 0.3);
            margin-right: auto;
        }

        .chat-input {
            display: flex;
            gap: 0.5rem;
        }

        .chat-input input {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.2);
            padding: 0.8rem;
            border-radius: 4px;
            color: var(--neon-teal);
        }

        .chat-input button {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--neon-teal);
            color: var(--neon-teal);
            padding: 0.8rem 1.2rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .chat-input button:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        .visualization-container {
            position: fixed;
            left: 300px;
            right: 300px;
            top: 0;
            bottom: 0;
            z-index: 0;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .visualization-container.visible {
            opacity: 1;
        }

        canvas {
            position: absolute !important;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
        }

        .face-container {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 500px;
            z-index: 1;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .face-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.3s ease;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.9);
        }

        .particle.tentacle {
            width: 5px;
            height: 5px;
            background: rgba(0, 255, 255, 0.9);
            box-shadow: 0 0 40px rgba(0, 255, 255, 1);
        }

        .particle.fractal {
            width: 3px;
            height: 3px;
            background: rgba(0, 255, 255, 1);
            box-shadow: 0 0 35px rgba(0, 255, 255, 1);
        }

        .particle.energy {
            width: 2px;
            height: 2px;
            background: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.9);
        }

        .face-container::before {
            content: '';
            position: absolute;
            top: -100%;
            left: -100%;
            width: 300%;
            height: 300%;
            background: radial-gradient(
                circle at center,
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.1) 30%,
                rgba(0, 0, 0, 0.2) 60%,
                rgba(0, 0, 0, 0.3) 80%
            );
            z-index: -1;
        }

        @keyframes tentacleFlow {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        @keyframes fractalGlow {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.6;
            }
            50% { 
                transform: scale(1.2);
                opacity: 0.3;
            }
        }

        @keyframes energyPulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.3;
            }
            50% { 
                transform: scale(1.5);
                opacity: 0.1;
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        @keyframes eyePulse {
            0%, 100% { 
                opacity: 0.8;
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.9);
            }
            50% { 
                opacity: 1;
                box-shadow: 0 0 30px rgba(0, 255, 255, 1);
            }
        }

        @keyframes eyeGlow {
            0%, 100% { box-shadow: 0 0 25px rgba(0, 255, 255, 1); }
            50% { box-shadow: 0 0 35px rgba(0, 255, 255, 1); }
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(1px, 1px); }
            50% { transform: translate(-1px, 0.5px); }
            75% { transform: translate(0.5px, -1px); }
        }

        @keyframes circuitFlow {
            0% { opacity: 0.3; }
            50% { opacity: 0.8; }
            100% { opacity: 0.3; }
        }

        .kraken-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            overflow: hidden;
        }

        .tentacle-particle {
            position: absolute;
            background: rgba(0, 255, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            transform-origin: center;
        }

        .branch-particle {
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }

        .float-particle {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .center-orb {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 20px rgba(255, 255, 255, 0.8),
                0 0 40px rgba(255, 255, 255, 0.6),
                0 0 60px rgba(255, 255, 255, 0.4);
            animation: orbPulse 4s ease-in-out infinite;
        }

        @keyframes orbPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 
                    0 0 20px rgba(255, 255, 255, 0.8),
                    0 0 40px rgba(255, 255, 255, 0.6),
                    0 0 60px rgba(255, 255, 255, 0.4);
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.2);
                box-shadow: 
                    0 0 30px rgba(255, 255, 255, 0.9),
                    0 0 60px rgba(255, 255, 255, 0.7),
                    0 0 90px rgba(255, 255, 255, 0.5);
            }
        }
    </style>
</head>
<body>
    <div class="face-container">
        <div class="face">
            <div class="face-part eye eye-left"></div>
            <div class="face-part eye eye-right"></div>
            <div class="glitch-overlay"></div>
        </div>
    </div>
    <div class="visualization-container"></div>
    <div id="ui">Loading...</div>
    <template id="metadata-template">
        <div class="metadata-panel">
            <button class="close-btn">×</button>
            <div class="metadata-content">
                <h3 class="title"></h3>
                <div class="audio-player-container">
                    <audio class="player" controls></audio>
                </div>
                <iframe class="youtube-embed" 
                        allowfullscreen
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture">
                </iframe>
                <table>
                    <tr><td>Duration:</td><td class="duration"></td></tr>
                </table>
            </div>
        </div>
    </template>

    <div class="side-panel left-panel">
        <h2>Analytics</h2>
        <div class="analytics-item">
            <h3>Audio Distribution</h3>
            <div class="chart-container" id="distributionChart">
                <!-- Chart will be rendered here -->
            </div>
            <p>Total Samples: <span id="totalSamples">0</span></p>
        </div>
        <div class="analytics-item">
            <h3>Duration Stats</h3>
            <p>Average Duration: <span id="avgDuration">0:00</span></p>
            <p>Longest Sample: <span id="maxDuration">0:00</span></p>
            <p>Shortest Sample: <span id="minDuration">0:00</span></p>
        </div>
        <div class="analytics-item">
            <h3>Categories</h3>
            <div id="categories">
                <!-- Categories will be populated here -->
            </div>
        </div>
    </div>

    <div class="side-panel right-panel">
        <div class="chat-container">
            <h2>Voice Agent Launcher</h2>L
            <div class="chat-messages" id="chatMessages">
                <div class="message bot-message">
                    Welcome! Let's launch your AI voice agent. What's the name of the voice you wanna use?
                </div>
            </div>
            <div class="chat-input">
                <input type="text" id="chatInput" placeholder="Type your message...">
                <button onclick="sendMessage()">Send</button>
            </div>
        </div>
    </div>

    <div class="kraken-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
let scene, camera, renderer, controls;
let audioNodes = [];
let currentPanel = null;
let audioContextInitialized = false;
let visualizationInitialized = false;


class AudioNode {
    constructor(position, data, index, totalNodes) {
        this.data = data;
        this.mesh = new THREE.Mesh(
            new THREE.CircleGeometry(0.4, 32),
            new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0,
                depthTest: false,
                depthWrite: false,
                side: THREE.DoubleSide
            })
        );
        
        this.mesh.lookAt(new THREE.Vector3(0, 0, 1));
        
        if (data && data.source) {
            try {
                const videoId = this.extractVideoId(data.source);
                // Look specifically for t=XXs format
                const timeMatch = data.source.match(/[?&]t=(\d+)s?/);
                const startTime = timeMatch ? parseInt(timeMatch[1]) : 0;
                
                // Construct embed URL with start time if present
                this.embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1${startTime ? '&start=' + startTime : ''}`;
                console.log('Video will start at:', startTime, 'seconds');
                console.log('Final embed URL:', this.embedUrl);
            } catch (error) {
                console.error('Error processing YouTube URL:', error);
            }
        }
        
        // Start at center
        this.mesh.position.set(0, 0, 0);
        this.targetPosition = position.clone();
        this.animationProgress = 0;
        this.randomOffset = new THREE.Vector3(
            (Math.random() - 0.5) * 0.8,
            (Math.random() - 0.5) * 0.8,
            (Math.random() - 0.5) * 0.8
        );

        // Stagger the start time based on index
        this.startDelay = (index / totalNodes) * 0.5; // 0.5 seconds total stagger
        this.hasStarted = false;
        this.elapsedTime = 0;
        
        // Create label with 0 opacity
        this.label = document.createElement('div');
        this.label.className = 'node-label';
        this.label.textContent = data.emoji;
        this.label.style.opacity = '0';
        document.body.appendChild(this.label);
    }

    update(deltaTime) {
        const ANIMATION_SPEED = 1.2;
        this.elapsedTime += deltaTime;

        if (this.elapsedTime < this.startDelay) {
            return;
        }

        if (!this.hasStarted) {
            this.hasStarted = true;
            this.animationProgress = 0;
        }
        
        if (this.animationProgress < 1) {
            this.animationProgress += deltaTime * ANIMATION_SPEED;
            this.animationProgress = Math.min(this.animationProgress, 1);
            
            const t = this.animationProgress;
            const eased = t < 0.5 
                ? 4 * t * t * t 
                : 1 + Math.sin((t - 0.5) * Math.PI) * Math.exp(-(t - 0.5) * 2.5) * 0.35;
            
            const progress = eased;
            const overshotPosition = this.targetPosition.clone().add(
                this.targetPosition.clone().normalize().multiplyScalar(3.5 * (1 - progress))
            );
            
            const currentOffset = this.randomOffset.clone().multiplyScalar(1 - progress);
            
            this.mesh.position.lerpVectors(
                new THREE.Vector3(0, 0, 0),
                overshotPosition.add(currentOffset),
                progress
            );

            // Make circle continuously face camera
            this.mesh.lookAt(camera.position);
            
            // Adjust opacity
            const fadeProgress = Math.min(this.animationProgress * 2, 1);
            this.mesh.material.opacity = 0.25 * fadeProgress;  // Reduced opacity for subtler effect
            this.label.style.opacity = fadeProgress;
        }
    }

    updateLabelPosition() {
        const vector = this.mesh.position.clone().project(camera);
        const container = document.querySelector('.visualization-container');
        const rect = container.getBoundingClientRect();
        
        this.label.style.left = `${rect.left + (vector.x + 1) * rect.width / 2}px`;
        this.label.style.top = `${rect.top + (-vector.y + 1) * rect.height / 2}px`;
    }

    extractVideoId(url) {
        // Handle both youtube.com and youtu.be formats
        const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
        const match = url.match(regExp);
        return (match && match[7].length === 11) ? match[7] : null;
    }

    onClick() {
        if (!this.embedUrl) return;
        
        const modal = document.createElement('div');
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        modal.style.display = 'flex';
        modal.style.justifyContent = 'center';
        modal.style.alignItems = 'center';
        modal.style.zIndex = '1000';

        const iframe = document.createElement('iframe');
        iframe.width = '800';
        iframe.height = '450';
        iframe.src = this.embedUrl;
        iframe.frameBorder = '0';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
        iframe.allowFullscreen = true;

        modal.appendChild(iframe);
        console.log('Opening video at URL:', iframe.src); // Debug log

        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });

        document.body.appendChild(modal);
    }
}

async function init() {
    scene = new THREE.Scene();
    
    // Get the visualization container dimensions
    const container = document.querySelector('.visualization-container');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    camera = new THREE.PerspectiveCamera(75, containerWidth/containerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true 
    });
    
    renderer.setSize(containerWidth, containerHeight);
    container.appendChild(renderer.domElement);
    
    try {
        const response = await fetch('audio/metadata.json');
        const audioFiles = await response.json();
        
        const nodeCount = audioFiles.length;
        // Adjust radius for better distribution
        const radius = 18 + Math.cbrt(nodeCount) * 1.2;

        audioFiles.forEach((file, index) => {
            const phi = Math.acos(-1 + (2 * index)/nodeCount);
            const theta = Math.sqrt(nodeCount * Math.PI) * phi;
            
            const position = new THREE.Vector3(
                Math.cos(theta) * radius * Math.sin(phi),
                Math.sin(theta) * radius * Math.sin(phi),
                Math.cos(phi) * radius
            );

            const node = new AudioNode(position, file, index, nodeCount);
            scene.add(node.mesh);
            audioNodes.push(node);
        });

        document.getElementById('ui').textContent = `Voice Agent Sphere Ready`;
        // Make visualization visible
        document.querySelector('.visualization-container').classList.add('visible');

    } catch (error) {
        document.getElementById('ui').textContent = `Error: ${error.message}`;
        return;
    }

    // Adjust camera and controls
    camera.position.z = 40;
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;
    controls.minDistance = 30;
    controls.maxDistance = 80;
    
    // Add this to make circles always face camera
    scene.onBeforeRender = () => {
        audioNodes.forEach(node => {
            node.mesh.lookAt(camera.position);
        });
    };

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    renderer.domElement.addEventListener('click', (e) => {
        if (!audioContextInitialized) {
            audioContextInitialized = true;
            const context = new (window.AudioContext || window.webkitAudioContext)();
            context.resume();
        }

        const rect = renderer.domElement.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        mouse.x = (x / rect.width) * 2 - 1;
        mouse.y = -(y / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(audioNodes.map(n => n.mesh));
        
        if (intersects.length > 0) {
            const node = audioNodes.find(n => n.mesh === intersects[0].object);
            showMetadataPanel(node, e.clientX, e.clientY);
        }
    });

    animate();
}

function showMetadataPanel(node, x, y) {
    if (currentPanel) currentPanel.remove();

    const template = document.getElementById('metadata-template');
    const panel = template.content.cloneNode(true).querySelector('.metadata-panel');
    
    panel.querySelector('.title').textContent = `${node.data.emoji} ${node.data.name}`;
    panel.querySelector('.duration').textContent = node.data.duration;
    
    const audio = panel.querySelector('audio');
    audio.src = `audio/${node.data.filename}`;

    const videoId = extractYoutubeId(node.data.source);
    const iframe = panel.querySelector('iframe');
    iframe.src = `https://www.youtube.com/embed/${videoId}?modestbranding=1&rel=0`;

    panel.querySelector('.close-btn').addEventListener('click', () => {
        panel.remove();
        currentPanel = null;
    });

    panel.style.left = `${Math.min(x - 180, window.innerWidth - 360)}px`;
    panel.style.top = `${Math.max(y - 50, 20)}px`;
    document.body.appendChild(panel);
    currentPanel = panel;
}

function extractYoutubeId(url) {
    const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
    const match = url.match(regExp);
    return (match && match[2].length === 11) ? match[2] : null;
}

function animate() {
    requestAnimationFrame(animate);
    
    const time = performance.now();
    const deltaTime = (time - (animate.lastTime || time)) / 1000;
    animate.lastTime = time;

    audioNodes.forEach(node => {
        node.update(deltaTime);
        node.updateLabelPosition();
    });
    
    controls.update();
    renderer.render(scene, camera);
}

window.onresize = () => {
    const container = document.querySelector('.visualization-container');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    camera.aspect = containerWidth / containerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(containerWidth, containerHeight);
};

// Dummy analytics data
function updateAnalytics(audioFiles) {
    document.getElementById('totalSamples').textContent = audioFiles.length;
    
    // Calculate duration stats
    const durations = audioFiles.map(file => {
        const [mins, secs] = file.duration.split(':').map(Number);
        return mins * 60 + secs;
    });
    
    const avgSeconds = durations.reduce((a, b) => a + b, 0) / durations.length;
    const maxSeconds = Math.max(...durations);
    const minSeconds = Math.min(...durations);
    
    document.getElementById('avgDuration').textContent = formatDuration(avgSeconds);
    document.getElementById('maxDuration').textContent = formatDuration(maxSeconds);
    document.getElementById('minDuration').textContent = formatDuration(minSeconds);
    
    // Create dummy distribution chart
    const ctx = document.createElement('canvas');
    document.getElementById('distributionChart').appendChild(ctx);
    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['0-30s', '30-60s', '60-90s', '90-120s', '120s+'],
            datasets: [{
                label: 'Duration Distribution',
                data: [4, 8, 15, 7, 3],
                backgroundColor: 'rgba(0, 255, 255, 0.2)',
                borderColor: 'rgba(0, 255, 255, 0.8)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    labels: {
                        color: 'rgba(0, 255, 255, 0.8)'
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(0, 255, 255, 0.1)'
                    },
                    ticks: {
                        color: 'rgba(0, 255, 255, 0.8)'
                    }
                },
                x: {
                    grid: {
                        color: 'rgba(0, 255, 255, 0.1)'
                    },
                    ticks: {
                        color: 'rgba(0, 255, 255, 0.8)'
                    }
                }
            }
        }
    });
}

function formatDuration(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Chat functionality
function sendMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    if (!message) return;
    
    const chatMessages = document.getElementById('chatMessages');
    
    // Add user message
    const userMsg = document.createElement('div');
    userMsg.className = 'message user-message';
    userMsg.textContent = message;
    chatMessages.appendChild(userMsg);
    
    // Initialize visualization on first message if not already done
    if (!visualizationInitialized) {
        // Hide both the face container and kraken container
        const faceContainer = document.querySelector('.face-container');
        const krakenContainer = document.querySelector('.kraken-container');
        
        // Fade out face
        faceContainer.style.transition = 'opacity 1s ease';
        faceContainer.classList.add('hidden');
        
        // Fade out kraken
        krakenContainer.style.transition = 'opacity 1s ease';
        krakenContainer.style.opacity = '0';
        
        // Remove containers after fade
        setTimeout(() => {
            faceContainer.style.display = 'none';
            krakenContainer.style.display = 'none';
        }, 1000);
        
        init();
        visualizationInitialized = true;
        document.getElementById('ui').style.opacity = '1';
    }
    
    // Add bot response
    const botMsg = document.createElement('div');
    botMsg.className = 'message bot-message';
    botMsg.textContent = `Great choice! I've initialized the voice agent sphere with "${message}". Click any emoji to hear a sample.`;
    chatMessages.appendChild(botMsg);
    
    // Clear input and scroll to bottom
    input.value = '';
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

// Add event listener for Enter key in chat input
document.getElementById('chatInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        sendMessage();
    }
});

// Modify the existing init() function to call updateAnalytics
const originalInit = init;
init = async function() {
    await originalInit();
    const response = await fetch('audio/metadata.json');
    const audioFiles = await response.json();
    updateAnalytics(audioFiles);
};

// init();  // Remove this line since we'll call it after first chat message

// Face particle system
class KrakenEffect {
    constructor() {
        this.container = document.querySelector('.kraken-container');
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;
        this.particles = [];
        this.time = 0;
        this.mouseX = this.centerX;
        this.mouseY = this.centerY;
        
        // Adjusted counts for better balance
        this.numTentacles = 8;  // Increased from 6
        this.maxDepth = 3;      // Keep at 3 for performance
        this.floatingParticles = 80; // Increased from 50
        
        // Performance settings
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / 30;
        this.mouseThrottle = 0;
        this.transformUpdates = new Map();
        
        this.init();
    }

    init() {
        // Remove center orb creation
        this.bindEvents();
        this.createFractals();
        this.animate();
    }

    bindEvents() {
        // Throttle mouse events
        let lastMouseMove = 0;
        window.addEventListener('mousemove', (e) => {
            const now = performance.now();
            if (now - lastMouseMove > 16) { // ~60fps throttle
                this.mouseX = e.clientX;
                this.mouseY = e.clientY;
                lastMouseMove = now;
            }
        }, { passive: true });
    }

    createFractals() {
        // Create main branches with wider spread
        for (let i = 0; i < this.numTentacles; i++) {
            const angle = (i / this.numTentacles) * Math.PI * 2;
            this.createBranch(
                this.centerX,
                this.centerY,
                300, // Increased length
                angle,
                0
            );
        }

        // Add floating particles with wider distribution
        for (let i = 0; i < this.floatingParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 250; // Increased radius
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            
            const particle = this.createParticle(x, y, 'float-particle', 2);
            particle.angle = angle;
            particle.radius = radius;
            particle.speed = 0.2 + Math.random() * 0.2;
        }
    }

    createBranch(startX, startY, length, angle, depth) {
        if (depth >= this.maxDepth) return;

        const segments = 10 - depth * 2; // Increased base segments
        const segmentLength = length / segments;
        let currentX = startX;
        let currentY = startY;

        for (let i = 0; i < segments; i++) {
            const t = i / segments;
            const size = 3.5 * (1 - depth/this.maxDepth) * (1 - t * 0.5);
            
            const particle = this.createParticle(
                currentX,
                currentY,
                'branch-particle',
                size
            );

            Object.assign(particle, {
                baseX: currentX,
                baseY: currentY,
                angle,
                segment: t,
                depth
            });

            // Adjusted branching for better coverage
            if (t > 0.2 && Math.random() < 0.5 - depth * 0.15) {
                const branchAngle = angle + (Math.random() - 0.5) * Math.PI * 1.2;
                this.createBranch(
                    currentX,
                    currentY,
                    length * 0.6, // Increased child branch length
                    branchAngle,
                    depth + 1
                );
            }

            currentX += Math.cos(angle) * segmentLength;
            currentY += Math.sin(angle) * segmentLength;
        }
    }

    animate = (timestamp) => {
        // Implement frame rate limiting
        if (timestamp - this.lastFrameTime < this.frameInterval) {
            requestAnimationFrame(this.animate);
            return;
        }
        this.lastFrameTime = timestamp;

        this.time += 0.016;
        this.transformUpdates.clear();
        
        // Batch particle updates
        this.particles.forEach(particle => {
            let x = particle.baseX;
            let y = particle.baseY;
            
            if (particle.depth !== undefined) {
                // Simplified wave calculation
                const wave = Math.sin(this.time * 2 + particle.segment * 5) * 
                    (20 - particle.depth * 5);
                const wave2 = Math.cos(this.time + particle.segment * 3) * 
                    (15 - particle.depth * 4);
                
                x += Math.cos(particle.angle) * wave;
                y += Math.sin(particle.angle) * wave2;
            } else {
                particle.angle += particle.speed * 0.02;
                const radius = particle.radius * (1 + Math.sin(this.time) * 0.1);
                x = this.centerX + Math.cos(particle.angle) * radius;
                y = this.centerY + Math.sin(particle.angle) * radius;
            }
            
            // Simplified mouse interaction
            const dx = this.mouseX - x;
            const dy = this.mouseY - y;
            const dist = Math.hypot(dx, dy);
            
            if (dist < 150) {
                const force = (1 - dist / 150) * 15;
                x += (dx / dist) * force;
                y += (dy / dist) * force;
            }
            
            this.transformUpdates.set(
                particle.element, 
                `translate(${x}px, ${y}px)`
            );
        });

        // Batch DOM updates
        this.transformUpdates.forEach((transform, element) => {
            element.style.transform = transform;
        });
        
        requestAnimationFrame(this.animate);
    }

    createParticle(x, y, className, size = 2) {
        const particle = document.createElement('div');
        particle.className = `tentacle-particle ${className}`;
        particle.style.width = size + 'px';
        particle.style.height = size + 'px';
        this.container.appendChild(particle);
        
        const particleObj = { element: particle, x, y, baseX: x, baseY: y };
        this.particles.push(particleObj);
        return particleObj;
    }
}

// Initialize the effect
const krakenEffect = new KrakenEffect();
</script>
</body>
</html>
