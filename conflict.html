<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>AI Voice Agent Launchpad</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        #ui {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(0, 255, 255, 0.8);
            font-size: 1.2em;
            opacity: 0;
            transition: opacity 0.5s ease-in;
            z-index: 100;
            text-align: center;
            pointer-events: none;
        }

        /* Add fade out animation */
        @keyframes uiFadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .ui-fade-out {
            animation: uiFadeOut 2s ease-out forwards;
        }

        :root {
            --space-black: #0a0a0f;
            --neon-teal: rgba(0, 255, 255, 0.8);
            --glass-panel: rgba(10, 10, 18, 0.96);
            --subtle-border: rgba(0, 255, 255, 0.2);
        }

        body {
            background: var(--space-black);
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            color: #e0e0e0;
            user-select: none; /* Prevent text selection globally */
        }

        .metadata-panel {
            position: fixed;
            background: var(--glass-panel);
            border: 1px solid var(--subtle-border);
            border-radius: 12px;
            padding: 1.5rem;
            padding-top: 2.5rem;
            width: 360px;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: grid;
            gap: 1rem;
            border-image: linear-gradient(
                145deg,
                rgba(0, 255, 255, 0.15),
                rgba(0, 255, 255, 0.05)
            ) 1;
            z-index: 35;
        }

        .metadata-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .audio-player-container {
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 0.5rem 0;
        }

        audio {
            width: 100%;
            filter: drop-shadow(0 2px 4px rgba(0, 255, 255, 0.1));
        }

        audio::-webkit-media-controls-panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
        }

        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: grid;
            place-items: center;
            transition: all 0.3s ease;
            z-index: 1001;
        }

        .close-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--neon-teal);
            transform: rotate(90deg);
        }

        .node-label {
            position: fixed;
            font-size: 1.8em;
            pointer-events: none !important;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            z-index: 10;
            color: #00ffff;
            user-select: none;
        }

        .audio-node {
            background: radial-gradient(
                circle at center,
                rgba(0, 255, 255, 0.15) 0%,
                transparent 70%
            );
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(0, 255, 255, 0.1);
        }

        .audio-node:hover {
            background: radial-gradient(
                circle at center,
                rgba(0, 255, 255, 0.25) 0%,
                transparent 70%
            );
            transform: scale(1.1);
        }

        .youtube-embed {
            width: 100%;
            aspect-ratio: 16/9;
            border: none;
            border-radius: 8px;
            margin-top: 1rem;
            background: #000;
        }

        .side-panel {
            position: fixed;
            top: 0;
            height: 100vh;
            width: 300px;
            background: var(--glass-panel);
            backdrop-filter: blur(20px);
            padding: 1.5rem;
            color: var(--neon-teal);
            overflow-y: auto;
            z-index: 30;
        }

        .left-panel {
            left: 0;
            border-right: 1px solid var(--subtle-border);
        }

        .right-panel {
            right: 0;
            border-left: 1px solid var(--subtle-border);
        }

        .analytics-item {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.1);
            box-sizing: border-box;
        }

        .chart-container {
            width: 100%;
            height: 200px;
            margin: 0.5rem 0;
            position: relative;
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 4px;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            box-sizing: border-box;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 3rem);
        }

        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
            z-index: 20;
            position: relative;
            user-select: text; /* Allow text selection only in specific areas */
        }

        .message {
            margin-bottom: 1rem;
            padding: 0.8rem;
            border-radius: 8px;
            max-width: 85%;
        }

        .user-message {
            background: rgba(0, 255, 255, 0.1);
            margin-left: auto;
        }

        .bot-message {
            background: rgba(0, 0, 0, 0.3);
            margin-right: auto;
        }

        .chat-input {
            position: relative;
            z-index: 31;
            display: flex;
            gap: 0.5rem;
            user-select: text; /* Allow text selection only in specific areas */
        }

        .chat-input input {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.2);
            padding: 0.8rem;
            border-radius: 4px;
            color: var(--neon-teal);
        }

        .chat-input button {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--neon-teal);
            color: var(--neon-teal);
            padding: 0.8rem 1.2rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .chat-input button:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        .visualization-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
        }

        .audio-visualizer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 20;
            perspective: 1000px;
            transform-style: preserve-3d;
            pointer-events: none;
        }

        .face-container {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 500px;
            z-index: 1;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .face-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.3s ease;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.9);
        }

        .particle.tentacle {
            width: 5px;
            height: 5px;
            background: rgba(0, 255, 255, 0.9);
            box-shadow: 0 0 40px rgba(0, 255, 255, 1);
        }

        .particle.fractal {
            width: 3px;
            height: 3px;
            background: rgba(0, 255, 255, 1);
            box-shadow: 0 0 35px rgba(0, 255, 255, 1);
        }

        .particle.energy {
            width: 2px;
            height: 2px;
            background: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.9);
        }

        .face-container::before {
            content: '';
            position: absolute;
            top: -100%;
            left: -100%;
            width: 300%;
            height: 300%;
            background: radial-gradient(
                circle at center,
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.1) 30%,
                rgba(0, 0, 0, 0.2) 60%,
                rgba(0, 0, 0, 0.3) 80%
            );
            z-index: -1;
        }

        @keyframes tentacleFlow {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        @keyframes fractalGlow {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.6;
            }
            50% { 
                transform: scale(1.2);
                opacity: 0.3;
            }
        }

        @keyframes energyPulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.3;
            }
            50% { 
                transform: scale(1.5);
                opacity: 0.1;
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        @keyframes eyePulse {
            0%, 100% { 
                opacity: 0.8;
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.9);
            }
            50% { 
                opacity: 1;
                box-shadow: 0 0 30px rgba(0, 255, 255, 1);
            }
        }

        @keyframes eyeGlow {
            0%, 100% { box-shadow: 0 0 25px rgba(0, 255, 255, 1); }
            50% { box-shadow: 0 0 35px rgba(0, 255, 255, 1); }
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(1px, 1px); }
            50% { transform: translate(-1px, 0.5px); }
            75% { transform: translate(0.5px, -1px); }
        }

        @keyframes circuitFlow {
            0% { opacity: 0.3; }
            50% { opacity: 0.8; }
            100% { opacity: 0.3; }
        }

        .kraken-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            overflow: hidden;
            cursor: pointer;
            z-index: 1;
            pointer-events: all;
        }

        .tentacle-particle {
            position: absolute;
            background: rgba(0, 255, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            transform-origin: center;
        }

        .branch-particle {
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }

        .float-particle {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .center-orb {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 20px rgba(255, 255, 255, 0.8),
                0 0 40px rgba(255, 255, 255, 0.6),
                0 0 60px rgba(255, 255, 255, 0.4);
            animation: orbPulse 4s ease-in-out infinite;
        }

        @keyframes orbPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 
                    0 0 20px rgba(255, 255, 255, 0.8),
                    0 0 40px rgba(255, 255, 255, 0.6),
                    0 0 60px rgba(255, 255, 255, 0.4);
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.2);
                box-shadow: 
                    0 0 30px rgba(255, 255, 255, 0.9),
                    0 0 60px rgba(255, 255, 255, 0.7),
                    0 0 90px rgba(255, 255, 255, 0.5);
            }
        }

        .choice-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--neon-teal);
            color: var(--neon-teal);
            padding: 0.5rem 1rem;
            margin: 0.3rem 0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            text-align: left;
        }

        .choice-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .video-grid {
            position: fixed;
            left: 350px;
            right: 350px;
            top: 50%;
            transform: translateY(-50%);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
            padding: 3rem;
            z-index: 35;
            max-height: 85vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--subtle-border);
        }

        .audio-clips-grid {
            position: fixed;
            left: 350px;
            right: 350px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            justify-content: center;
            gap: 3rem;
            padding: 3rem;
            z-index: 35;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--subtle-border);
        }

        .audio-clip-option {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--neon-teal);
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 200px;
        }

        .audio-clip-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.8);
        }

        .video-option {
            width: 100%;
            max-width: 280px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--neon-teal);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
        }

        .video-preview {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            overflow: hidden;
            background: #000;
            border-radius: 8px 8px 0 0;
        }

        .video-thumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }

        .video-duration {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .video-info {
            padding: 1rem;
            color: var(--neon-teal);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .video-title {
            font-size: 1.1rem;
            font-weight: 500;
        }

        .video-description {
            font-size: 0.9rem;
            opacity: 0.8;
            line-height: 1.4;
        }

        .video-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.8);
        }

        .video-option:hover .video-thumbnail {
            transform: scale(1.05);
        }

        .loading-percentage {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: var(--neon-teal);
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            z-index: 11;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .play-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid var(--neon-teal);
            color: var(--neon-teal);
            font-size: 32px;
            cursor: pointer;
            margin: 1rem auto;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-button:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .clip-label {
            color: var(--neon-teal);
            margin-top: 1.5rem;
            font-size: 1.2rem;
            font-weight: 500;
        }

        .side-panel {
            z-index: 30;
        }

        /* Add custom scrollbar for better visibility */
        .video-grid::-webkit-scrollbar {
            width: 8px;
            margin-right: 4px;
        }

        .video-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin: 4px;
        }

        .video-grid::-webkit-scrollbar-thumb {
            background: var(--neon-teal);
            border-radius: 4px;
        }

        .audio-clip-option audio {
            display: none;
        }

        /* Allow text selection only in specific areas */
        .chat-messages, 
        .chat-input input,
        .metadata-panel {
            user-select: text;
        }

        .node-glow {
            position: absolute;
            width: 40px;  /* Smaller, tighter around emoji */
            height: 40px;
            border-radius: 50%;
            pointer-events: none;
            background: radial-gradient(circle at center,
                rgba(0, 255, 255, 0.9) 0%,
                rgba(0, 255, 255, 0.6) 40%,
                rgba(0, 255, 255, 0.2) 70%,
                rgba(0, 255, 255, 0) 100%
            );
            filter: blur(4px) contrast(1.5);  /* Tighter blur */
            transform: scale(1);
            mix-blend-mode: screen;
            z-index: 100;
            animation: subtleGlow 2s ease-in-out;
        }

        @keyframes subtleGlow {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0; }
        }

        .audio-visualizer .tentacle-particle {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 1.5px;
            height: 1.5px;
            background: rgba(0, 255, 255, 0.9);
            border-radius: 50%;
            transform-origin: center;
            mix-blend-mode: screen;
            transition: transform 0.1s ease;
            transform-style: preserve-3d;
            will-change: transform;
        }

        .audio-visualizer .branch-particle {
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.7);
        }

        .audio-visualizer .float-particle {
            background: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 4px rgba(0, 255, 255, 0.6);
        }

        .ava-title {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: rgba(0, 255, 255, 0.8);
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            animation: titlePulse 40s ease-in-out infinite;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.3),
                         0 0 20px rgba(0, 255, 255, 0.2),
                         0 0 30px rgba(0, 255, 255, 0.1);
        }

        .ava-text {
            font-size: 8em;
            font-weight: 700;
            letter-spacing: 0.2em;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            background-image: linear-gradient(180deg, 
                rgba(0, 255, 255, 0.6) 0%,    /* Adjusted opacity */
                rgba(0, 255, 255, 0.5) 50%,    /* Adjusted opacity */
                rgba(0, 255, 255, 0.4) 100%    /* Adjusted opacity */
            );
        }

        .ava-subtitle {
            font-size: 2.5em;
            opacity: 0.6;  /* Adjusted from 0.8 */
            margin-top: 0.5em;
            font-weight: 400;
            letter-spacing: 0.3em;
        }

        @keyframes titlePulse {
            0% { opacity: 0; }
            40% { opacity: 0.6; }  /* Changed from 1.0 to 0.6 */
            80% { opacity: 0.2; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="face-container">
        <div class="face">
            <div class="face-part eye eye-left"></div>
            <div class="face-part eye eye-right"></div>
            <div class="glitch-overlay"></div>
        </div>
    </div>
    <div class="visualization-container"></div>
    <div id="ui">Loading...</div>
    <template id="metadata-template">
        <div class="metadata-panel">
            <button class="close-btn">Ã—</button>
            <div class="metadata-content">
                <h3 class="title"></h3>
                <div class="audio-player-container">
                    <audio class="player" controls></audio>
                </div>
                <iframe class="youtube-embed" 
                        allowfullscreen
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture">
                </iframe>
                <table>
                    <tr><td>Duration:</td><td class="duration"></td></tr>
                </table>
            </div>
        </div>
    </template>

    <div class="side-panel left-panel">
        <h2>Analytics</h2>
        <div class="analytics-item">
            <h3>Audio Distribution</h3>
            <div class="chart-container" id="distributionChart">
                <!-- Chart will be rendered here -->
            </div>
            <p>Total Samples: <span id="totalSamples">0</span></p>
        </div>
        <div class="analytics-item">
            <h3>Duration Stats</h3>
            <p>Average Duration: <span id="avgDuration">0:00</span></p>
            <p>Longest Sample: <span id="maxDuration">0:00</span></p>
            <p>Shortest Sample: <span id="minDuration">0:00</span></p>
        </div>
        <div class="analytics-item">
            <h3>Categories</h3>
            <div id="categories">
                <!-- Categories will be populated here -->
            </div>
        </div>
    </div>

    <div class="side-panel right-panel">
        <div class="chat-container">
            <h2>Voice Agent Launcher</h2>
            <div class="chat-messages" id="chatMessages">
                <div class="message bot-message">
                    Welcome! Let's launch your AI voice agent. What's the name of the voice you wanna use?
                </div>
            </div>
            <div class="chat-input">
                <input type="text" id="chatInput" placeholder="Type your message...">
                <button onclick="sendMessage()">Send</button>
            </div>
        </div>
    </div>

    <div class="kraken-container">
        <div class="ava-title">
            <div class="ava-text">AVA</div>
            <div class="ava-subtitle">AI Voice Agents</div>
        </div>
    </div>

    <div class="loading-percentage">0%</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
let scene, camera, renderer, controls;
let audioNodes = [];
let currentPanel = null;
let audioContextInitialized = false;
let visualizationInitialized = false;


class AudioNode {
    constructor(position, data, index, totalNodes) {
        this.data = data;
        this.mesh = new THREE.Mesh(
            new THREE.CircleGeometry(0.4, 32),
            new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0,
                depthTest: false,  // Disable depth testing
                depthWrite: false, // Disable depth writing
                side: THREE.DoubleSide,
                renderOrder: 1     // Ensure it renders on top
            })
        );
        
        // Add a larger invisible collision mesh for better click detection
        this.clickMesh = new THREE.Mesh(
            new THREE.SphereGeometry(1, 8, 8),
            new THREE.MeshBasicMaterial({
                visible: false,
                depthTest: false,
                depthWrite: false
            })
        );
        this.clickMesh.position.copy(position);
        this.clickMesh.userData = this.mesh.userData;
        
        this.mesh.lookAt(new THREE.Vector3(0, 0, 1));
        
        if (data && data.source) {
            try {
                const videoId = this.extractVideoId(data.source);
                // Look specifically for t=XXs format
                const timeMatch = data.source.match(/[?&]t=(\d+)s?/);
                const startTime = timeMatch ? parseInt(timeMatch[1]) : 0;
                
                // Construct embed URL with start time if present
                this.embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1${startTime ? '&start=' + startTime : ''}`;
                console.log('Video will start at:', startTime, 'seconds');
                console.log('Final embed URL:', this.embedUrl);
            } catch (error) {
                console.error('Error processing YouTube URL:', error);
            }
        }
        
        // Start at center
        this.mesh.position.set(0, 0, 0);
        this.targetPosition = position.clone();
        this.animationProgress = 0;
        this.randomOffset = new THREE.Vector3(
            (Math.random() - 0.5) * 0.8,
            (Math.random() - 0.5) * 0.8,
            (Math.random() - 0.5) * 0.8
        );

        // Stagger the start time based on index
        this.startDelay = (index / totalNodes) * 0.5; // 0.5 seconds total stagger
        this.hasStarted = false;
        this.elapsedTime = 0;
        
        // Create label with 0 opacity
        this.label = document.createElement('div');
        this.label.className = 'node-label';
        this.label.textContent = data.emoji;
        this.label.style.opacity = '0';
        document.body.appendChild(this.label);

        // Add click handling
        this.mesh.userData = {
            type: 'audioNode',
            metadata: data
        };
    }

    update(deltaTime) {
        const ANIMATION_SPEED = 1.2;
        this.elapsedTime += deltaTime;

        if (this.elapsedTime < this.startDelay) {
            return;
        }

        if (!this.hasStarted) {
            this.hasStarted = true;
            this.animationProgress = 0;
        }
        
        if (this.animationProgress < 1) {
            this.animationProgress += deltaTime * ANIMATION_SPEED;
            this.animationProgress = Math.min(this.animationProgress, 1);
            
            const t = this.animationProgress;
            const eased = t < 0.5 
                ? 4 * t * t 
                : 1 + Math.sin((t - 0.5) * Math.PI) * 0.35;
            
            const progress = eased;
            const overshotPosition = this.targetPosition.clone().add(
                this.targetPosition.clone().normalize().multiplyScalar(3.5 * (1 - progress))
            );
            
            const currentOffset = this.randomOffset.clone().multiplyScalar(1 - progress);
            
            this.mesh.position.lerpVectors(
                new THREE.Vector3(0, 0, 0),
                overshotPosition.add(currentOffset),
                progress
            );

            // Make circle continuously face camera
            this.mesh.lookAt(camera.position);
            
            // Adjust opacity
            const fadeProgress = Math.min(this.animationProgress * 2, 1);
            this.mesh.material.opacity = 0.25 * fadeProgress;  // Reduced opacity for subtler effect
            this.label.style.opacity = fadeProgress;
        }

        // Update clickMesh position to match visible mesh
        this.clickMesh.position.copy(this.mesh.position);
        this.clickMesh.lookAt(camera.position);
    }

    updateLabelPosition() {
        const vector = this.mesh.position.clone().project(camera);
        const container = document.querySelector('.visualization-container');
        const rect = container.getBoundingClientRect();
        
        this.label.style.left = `${rect.left + (vector.x + 1) * rect.width / 2}px`;
        this.label.style.top = `${rect.top + (-vector.y + 1) * rect.height / 2}px`;
    }

    extractVideoId(url) {
        // Handle both youtube.com and youtu.be formats
        const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
        const match = url.match(regExp);
        return (match && match[7].length === 11) ? match[7] : null;
    }

    onClick() {
        if (this.mesh.userData.metadata) {
            showMetadataPanel(this.mesh.userData.metadata);
        }
    }
}

async function init() {
    scene = new THREE.Scene();
    
    // Get the visualization container dimensions
    const container = document.querySelector('.visualization-container');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    camera = new THREE.PerspectiveCamera(75, containerWidth/containerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true 
    });
    
    renderer.setSize(containerWidth, containerHeight);
    container.appendChild(renderer.domElement);
    
    try {
        const response = await fetch('audio/metadata.json');
        const audioFiles = await response.json();
        
        const nodeCount = audioFiles.length;
        // Adjust radius for better distribution
        const radius = 18 + Math.cbrt(nodeCount) * 1.2;

        audioFiles.forEach((file, index) => {
            const phi = Math.acos(-1 + (2 * index)/nodeCount);
            const theta = Math.sqrt(nodeCount * Math.PI) * phi;
            
            const position = new THREE.Vector3(
                Math.cos(theta) * radius * Math.sin(phi),
                Math.sin(theta) * radius * Math.sin(phi),
                Math.cos(phi) * radius * 1.5 // Increased Z spread
            );

            const node = new AudioNode(position, file, index, nodeCount);
            scene.add(node.mesh);
            audioNodes.push(node);
        });

        document.getElementById('ui').textContent = `Audio Dataset Deployed as NFT Contract`;
        document.getElementById('ui').style.opacity = '1';
        
        // Add fade out after a delay
        setTimeout(() => {
            document.getElementById('ui').classList.add('ui-fade-out');
        }, 2000); // Wait 2 seconds before starting fade
        
        // Set visualization as initialized so TTS requests work
        visualizationInitialized = true;

    } catch (error) {
        document.getElementById('ui').textContent = `Error: ${error.message}`;
        return;
    }

    // Adjust camera and controls
    camera.position.z = 60; // Increased from 40
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;
    controls.minDistance = 30;
    controls.maxDistance = 80;
    controls.enabled = true;  // Make sure controls are enabled

    // Add raycaster for clicking nodes
    const raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 1;
    const mouse = new THREE.Vector2();
    
    renderer.domElement.addEventListener('click', (event) => {
        // Calculate mouse position in normalized device coordinates
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        // Update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // Calculate objects intersecting the picking ray
        const intersects = raycaster.intersectObjects([
            ...audioNodes.map(node => node.mesh),
            ...audioNodes.map(node => node.clickMesh)
        ]);

        if (intersects.length > 0) {
            const node = audioNodes.find(n => 
                n.mesh === intersects[0].object || 
                n.clickMesh === intersects[0].object
            );
            if (node && node.data) {
                showMetadataPanel(node.data, event);
            }
        }
    });

    animate();
}

function showMetadataPanel(metadata, event) {
    if (currentPanel) {
        currentPanel.remove();
    }

    const template = document.getElementById('metadata-template');
    const panel = template.content.cloneNode(true).children[0];
    
    // Fill in metadata
    panel.querySelector('.title').textContent = metadata.name;
    panel.querySelector('.duration').textContent = metadata.duration;
    
    // Set up audio player
    const player = panel.querySelector('.player');
    player.src = `audio/${metadata.filename}`;
    
    // Set up YouTube embed
    const embed = panel.querySelector('.youtube-embed');
    if (metadata.source) {
        const videoId = extractVideoId(metadata.source);
        if (videoId) {
            embed.src = `https://www.youtube.com/embed/${videoId}`;
            embed.style.display = 'block';
        } else {
            embed.style.display = 'none';
        }
    } else {
        embed.style.display = 'none';
    }
    
    // Position panel near click
    const padding = 20;
    const maxRight = window.innerWidth - panel.offsetWidth - padding;
    const maxBottom = window.innerHeight - panel.offsetHeight - padding;
    
    panel.style.position = 'fixed';
    panel.style.left = `${Math.min(event.clientX, maxRight)}px`;
    panel.style.top = `${Math.min(event.clientY, maxBottom)}px`;
    
    // Set up close button
    panel.querySelector('.close-btn').addEventListener('click', () => {
        panel.remove();
        currentPanel = null;
    });
    
    document.body.appendChild(panel);
    currentPanel = panel;
}

function extractVideoId(url) {
    const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
    const match = url.match(regExp);
    return (match && match[7].length === 11) ? match[7] : null;
}

function animate() {
    requestAnimationFrame(animate);
    
    const time = performance.now();
    const deltaTime = (time - (animate.lastTime || time)) / 1000;
    animate.lastTime = time;

    audioNodes.forEach(node => {
        node.update(deltaTime);
        node.updateLabelPosition();
    });
    
    controls.update();  // This is important for controls to work
    renderer.render(scene, camera);
}

window.onresize = () => {
    const container = document.querySelector('.visualization-container');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    camera.aspect = containerWidth / containerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(containerWidth, containerHeight);
};

// Dummy analytics data
function updateAnalytics(audioFiles) {
    document.getElementById('totalSamples').textContent = audioFiles.length;
    
    // Calculate duration stats
    const durations = audioFiles.map(file => {
        const [mins, secs] = file.duration.split(':').map(Number);
        return mins * 60 + secs;
    });
    
    const avgSeconds = durations.reduce((a, b) => a + b, 0) / durations.length;
    const maxSeconds = Math.max(...durations);
    const minSeconds = Math.min(...durations);
    
    document.getElementById('avgDuration').textContent = formatDuration(avgSeconds);
    document.getElementById('maxDuration').textContent = formatDuration(maxSeconds);
    document.getElementById('minDuration').textContent = formatDuration(minSeconds);
    
    // Create dummy distribution chart
    const ctx = document.createElement('canvas');
    document.getElementById('distributionChart').appendChild(ctx);
    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['0-30s', '30-60s', '60-90s', '90-120s', '120s+'],
            datasets: [{
                label: 'Duration Distribution',
                data: [4, 8, 15, 7, 3],
                backgroundColor: 'rgba(0, 255, 255, 0.2)',
                borderColor: 'rgba(0, 255, 255, 0.8)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    labels: {
                        color: 'rgba(0, 255, 255, 0.8)'
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(0, 255, 255, 0.1)'
                    },
                    ticks: {
                        color: 'rgba(0, 255, 255, 0.8)'
                    }
                },
                x: {
                    grid: {
                        color: 'rgba(0, 255, 255, 0.1)'
                    },
                    ticks: {
                        color: 'rgba(0, 255, 255, 0.8)'
                    }
                }
            }
        }
    });
}

function formatDuration(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Add this function to handle TTS requests
function handleTTSRequest(text) {
    const randomNode = audioNodes[Math.floor(Math.random() * audioNodes.length)];
    const glow = document.createElement('div');
    glow.className = 'node-glow';
    document.body.appendChild(glow);

    // Create an animation frame loop to track the node
    function updateGlowPosition() {
        const label = randomNode.label;
        const labelRect = label.getBoundingClientRect();
        glow.style.left = `${labelRect.left + (labelRect.width / 2) - 20}px`;
        glow.style.top = `${labelRect.top + (labelRect.height / 2) - 20}px`;
        
        if (glow.parentElement) { // Keep updating until glow is removed
            requestAnimationFrame(updateGlowPosition);
        }
    }
    updateGlowPosition();

    setTimeout(() => {
        glow.remove();
        showNFTDialog();
        setTimeout(startAudioVisualization, 500);
    }, 2000);
}

// Modify sendMessage to handle TTS requests
function sendMessage() {
    const input = document.getElementById('chatInput');
    const text = input.value.trim();
    
    if (!text) return;
    
    // Add user message
    const chatMessages = document.getElementById('chatMessages');
    const userMsg = document.createElement('div');
    userMsg.className = 'message user-message';
    userMsg.textContent = text;
    chatMessages.appendChild(userMsg);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    // Clear input
    input.value = '';
    
    // If we're at TTS stage, handle the request
    if (visualizationInitialized) {
        handleTTSRequest(text);
    }
}

// Modify the existing init() function to call updateAnalytics
const originalInit = init;
init = async function() {
    await originalInit();
    const response = await fetch('audio/metadata.json');
    const audioFiles = await response.json();
    updateAnalytics(audioFiles);
};

// init();  // Remove this line since we'll call it after first chat message

// Face particle system
class KrakenEffect {
    constructor() {
        this.container = document.querySelector('.kraken-container');
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;
        this.particles = [];
        this.time = 0;
        this.mouseX = this.centerX;
        this.mouseY = this.centerY;
        
        // Scale parameters based on screen size
        const screenSize = Math.min(this.width, this.height);
        const scaleFactor = Math.max(1, screenSize / 800); // Base scale on 800px reference
        
        this.numTentacles = 8;
        this.maxDepth = 3;
        this.floatingParticles = Math.floor(80 * scaleFactor);
        this.baseRadius = Math.min(400, 250 * scaleFactor); // Scale radius with screen
        this.branchLength = Math.min(500, 300 * scaleFactor); // Scale branch length
        
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / 30;
        this.mouseThrottle = 0;
        this.transformUpdates = new Map();
        
        this.transitioning = false;
        this.transitionProgress = 0;
        this.vortexStrength = 0;
        
        this.mode = 'normal'; // 'normal', 'loading', 'vortex'
        this.loadingProgress = 0;
        this.loadingParticles = [];
        
        // Add percentage display element
        this.percentageDisplay = document.createElement('div');
        this.percentageDisplay.className = 'loading-percentage';
        document.body.appendChild(this.percentageDisplay);
        
        this.init();
        
        // Bind the resize handler to this instance
        this.handleResize = this.handleResize.bind(this);
        window.addEventListener('resize', this.handleResize);

        // Add click handler to skip to sphere
        this.container.addEventListener('click', () => {
            // Skip loading animation and go straight to transition
            this.mode = 'normal';
            this.transitioning = true;
            this.transitionProgress = 0;
            this.vortexStrength = 0;
            
            // Initialize sphere immediately
            setTimeout(() => {
                init();
                visualizationInitialized = true;  // Also set it here
                document.getElementById('ui').style.opacity = '1';
                
                // Add blockchain message immediately
                const chatMessages = document.getElementById('chatMessages');
                const blockchainMsg = document.createElement('div');
                blockchainMsg.className = 'message bot-message';
                blockchainMsg.textContent = `Here is the audio dataset for your voice agent, this is now deployed to the Base blockchain and your agent will mint one of these pieces of audio as an NFT every time it processes a Text To Speech (TTS) request to create an immutable cryptographic record...`;
                chatMessages.appendChild(blockchainMsg);
                
                // Add TTS prompt with shorter delay
                setTimeout(() => {
                    const ttsPrompt = document.createElement('div');
                    ttsPrompt.className = 'message bot-message';
                    ttsPrompt.textContent = `Why don't you try a TTS request for your agent right now?`;
                    chatMessages.appendChild(ttsPrompt);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, 500); // Reduced from 1000ms to 500ms
                
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 400); // Reduced from 800ms to 400ms
        });
    }

    init() {
        this.bindEvents();
        this.createFractals();
        this.animate();
        
        // Show AVA title immediately
        document.querySelector('.ava-title').style.opacity = '1';
    }

    bindEvents() {
        let lastMouseMove = 0;
        window.addEventListener('mousemove', (e) => {
            const now = performance.now();
            if (now - lastMouseMove > 16) {
                this.mouseX = e.clientX;
                this.mouseY = e.clientY;
                lastMouseMove = now;
            }
        }, { passive: true });
    }

    createFractals() {
        for (let i = 0; i < this.numTentacles; i++) {
            const angle = (i / this.numTentacles) * Math.PI * 2;
            this.createBranch(
                this.centerX,
                this.centerY,
                this.branchLength,
                angle,
                0
            );
        }

        for (let i = 0; i < this.floatingParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 45;
            const x = this.centerX + Math.cos(angle) * radius;
            const y = this.centerY + Math.sin(angle) * radius;
            
            const particle = this.createParticle(x, y, 'float-particle', 2);
            particle.angle = angle;
            particle.radius = radius;
            particle.speed = 0.2 + Math.random() * 0.2;
        }
    }

    createBranch(startX, startY, length, angle, depth) {
        if (depth >= this.maxDepth) return;

        const segments = 10 - depth * 2;
        const segmentLength = length / segments;
        let currentX = startX;
        let currentY = startY;

        for (let i = 0; i < segments; i++) {
            const t = i / segments;
            const size = 3.5 * (1 - depth/this.maxDepth) * (1 - t * 0.5);
            
            const particle = this.createParticle(
                currentX,
                currentY,
                'branch-particle',
                size
            );

            Object.assign(particle, {
                baseX: currentX,
                baseY: currentY,
                angle,
                segment: t,
                depth
            });

            if (t > 0.2 && Math.random() < 0.5 - depth * 0.15) {
                const branchAngle = angle + (Math.random() - 0.5) * Math.PI * 1.2;
                this.createBranch(
                    currentX,
                    currentY,
                    length * 0.6,
                    branchAngle,
                    depth + 1
                );
            }

            currentX += Math.cos(angle) * segmentLength;
            currentY += Math.sin(angle) * segmentLength;
        }
    }

    animate = (timestamp) => {
        if (timestamp - this.lastFrameTime < this.frameInterval) {
            requestAnimationFrame(this.animate);
            return;
        }
        this.lastFrameTime = timestamp;

        this.time += 0.016;
        this.transformUpdates.clear();
        
        if (this.mode === 'loading') {
            const progress = Math.min(1, this.loadingProgress / 100);
            const activeAngle = progress * Math.PI * 2;
            
            this.particles.forEach(particle => {
                // Update assembly progress
                particle.assembleProgress = Math.min(1, particle.assembleProgress + particle.assembleSpeed);
                
                // Ease function for smooth assembly
                const ease = t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                const assembleEased = ease(particle.assembleProgress);
                
                // Calculate current position
                const x = particle.startX + (particle.targetX - particle.startX) * assembleEased;
                const y = particle.startY + (particle.targetY - particle.startY) * assembleEased;
                
                // Add subtle orbital motion
                const orbitRadius = 2 * Math.sin(this.time * 2 + particle.angle * 3);
                const finalX = x + Math.cos(particle.angle) * orbitRadius;
                const finalY = y + Math.sin(particle.angle) * orbitRadius;
                
                // Highlight active progress
                let opacity = 0.3;
                if (particle.angle <= activeAngle) {
                    opacity = 0.8 + Math.sin(this.time * 4) * 0.2; // Pulsing effect
                }
                
                particle.element.style.opacity = opacity;
                particle.element.style.transform = `translate(${finalX}px, ${finalY}px) scale(${0.8 + Math.sin(this.time * 3 + particle.angle) * 0.2})`;
                
                // Store position for vortex transition
                particle.baseX = finalX;
                particle.baseY = finalY;
            });
        } else {
            if (this.transitioning) {
                this.transitionProgress += 0.025; // Even faster transition
                this.vortexStrength = Math.min(1, this.transitionProgress * 4); // More immediate force
            }
            
            this.particles.forEach(particle => {
                let x = particle.baseX;
                let y = particle.baseY;
                
                if (this.transitioning) {
                    const dx = x - this.centerX;
                    const dy = y - this.centerY;
                    const dist = Math.hypot(dx, dy);
                    const angle = Math.atan2(dy, dx);
                    
                    // Much stronger direct pull to center
                    const gravitationalPull = Math.max(0.2, (400 - dist) / 400) * this.vortexStrength * 4;
                    
                    // Minimal spiral effect
                    const angularVelocity = (1 + (400 - dist) / 400) * this.vortexStrength * 0.2;
                    
                    const newAngle = angle + angularVelocity * (particle.speed || 0.5);
                    
                    // More aggressive inward movement
                    const newDist = Math.max(5, dist - gravitationalPull * (20 + Math.random() * 5));
                    
                    x = this.centerX + Math.cos(newAngle) * newDist;
                    y = this.centerY + Math.sin(newAngle) * newDist;
                    
                    // Minimal turbulence
                    const turbulence = (400 - newDist) / 400 * 2 * this.vortexStrength;
                    x += Math.sin(this.time * 10 + dist) * turbulence;
                    y += Math.cos(this.time * 10 + dist) * turbulence;
                    
                    // Slight stretching towards center
                    const stretch = Math.min(1.2, (400 - newDist) / 400);
                    const radialStretch = `scaleX(${1 + stretch * this.vortexStrength}) scaleY(${1 / (1 + stretch * this.vortexStrength)})`;
                    
                    const opacity = Math.max(0, (newDist - 5) / 100);
                    particle.element.style.opacity = opacity;
                    
                    particle.element.style.transform = `translate(${x}px, ${y}px) rotate(${newAngle}rad) ${radialStretch}`;
                    
                    if (newDist < 5 || opacity <= 0) {
                        particle.element.remove();
                        return;
                    }
                    
                    particle.baseX = x;
                    particle.baseY = y;
                    
                } else {
                    // Normal animation code
                    if (particle.depth !== undefined) {
                        const wave = Math.sin(this.time * 2 + particle.segment * 5) * 
                            (20 - particle.depth * 5);
                        const wave2 = Math.cos(this.time + particle.segment * 3) * 
                            (15 - particle.depth * 4);
                        
                        x += Math.cos(particle.angle) * wave;
                        y += Math.sin(particle.angle) * wave2;
                    } else {
                        particle.angle += particle.speed * 0.02;
                        const radius = particle.radius * (1 + Math.sin(this.time) * 0.1);
                        x = this.centerX + Math.cos(particle.angle) * radius;
                        y = this.centerY + Math.sin(particle.angle) * radius;
                    }
                    
                    // Mouse interaction
                    const dx = this.mouseX - x;
                    const dy = this.mouseY - y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist < 150) {
                        const force = (1 - dist / 150) * 15;
                        x += (dx / dist) * force;
                        y += (dy / dist) * force;
                    }
                    
                    this.transformUpdates.set(
                        particle.element, 
                        `translate(${x}px, ${y}px)`
                    );
                }
            });
        }
        
        if (!this.transitioning) {
            this.transformUpdates.forEach((transform, element) => {
                element.style.transform = transform;
            });
        }
        
        requestAnimationFrame(this.animate);
    }

    createParticle(x, y, className, size = 2) {
        const particle = document.createElement('div');
        particle.className = `tentacle-particle ${className}`;
        particle.style.width = size + 'px';
        particle.style.height = size + 'px';
        this.container.appendChild(particle);
        
        const particleObj = { element: particle, x, y, baseX: x, baseY: y };
        this.particles.push(particleObj);
        return particleObj;
    }

    handleResize() {
        // Update dimensions
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;

        // Recalculate scale parameters
        const screenSize = Math.min(this.width, this.height);
        const scaleFactor = Math.max(1, screenSize / 800);
        
        // Update scaled values
        this.baseRadius = Math.min(400, 250 * scaleFactor);
        this.branchLength = Math.min(500, 300 * scaleFactor);

        // Clear existing particles
        this.particles.forEach(particle => {
            particle.element.remove();
        });
        this.particles = [];
        
        // Recreate the pattern with new dimensions
        this.createFractals();
    }

    // Add cleanup method to prevent memory leaks
    cleanup() {
        window.removeEventListener('resize', this.handleResize);
        this.particles.forEach(particle => {
            particle.element.remove();
        });
        this.particles = [];
        this.percentageDisplay.remove();
    }

    // Add transition method
    startTransition() {
        this.mode = 'normal';
        this.transitioning = true;
        this.transitionProgress = 0;
        this.vortexStrength = 0;
        
        // Debug title handling
        const titles = document.querySelectorAll('.ava-title');
        console.log('Found titles:', titles.length);
        
        const title = document.querySelector('.ava-title');
        if (title) {
            console.log('Title before:', {
                animation: title.style.animation,
                opacity: title.style.opacity,
                classList: [...title.classList]
            });
            
            title.classList.add('disappear');
            
            console.log('Title after adding class:', {
                animation: title.style.animation,
                opacity: title.style.opacity,
                classList: [...title.classList]
            });
            
            setTimeout(() => {
                console.log('Before removal, title exists:', !!document.querySelector('.ava-title'));
                title.remove();
                console.log('After removal, title exists:', !!document.querySelector('.ava-title'));
            }, 200);
        }
        
        // Initialize sphere
        setTimeout(() => {
            init();
            document.getElementById('ui').style.opacity = '1';
        }, 400);
    }

    startLoading(onComplete) {
        this.mode = 'loading';
        this.loadingProgress = 0;
        
        // Show the AVA title with fade in
        document.querySelector('.ava-title').style.opacity = '1';
        
        // Keep particles visible during transition
        this.particles.forEach(particle => {
            particle.element.style.opacity = '0.8';  // Start with high opacity
        });
        
        // Show percentage display with a fade
        this.percentageDisplay.style.opacity = '1';
        this.percentageDisplay.textContent = '0%';
        
        // Calculate circle parameters
        const radius = Math.min(this.width, this.height) * 0.2;
        const totalParticles = this.particles.length;
        
        // Assign target positions using current positions as starting points
        this.particles.forEach((particle, index) => {
            const angle = (index / totalParticles) * Math.PI * 2;
            const targetX = this.centerX + Math.cos(angle) * radius;
            const targetY = this.centerY + Math.sin(angle) * radius;
            
            // Use current position as starting point
            const startX = particle.baseX;
            const startY = particle.baseY;
            
            Object.assign(particle, {
                targetX,
                targetY,
                startX,
                startY,
                angle,
                assembleProgress: 0,
                assembleSpeed: 0.02 + Math.random() * 0.01  // Slightly slower for smoother transition
            });
        });

        const loadingInterval = setInterval(() => {
            this.loadingProgress += 0.8;  // Slightly slower progress
            
            // Update percentage display
            const percentage = Math.min(100, Math.floor(this.loadingProgress));
            this.percentageDisplay.textContent = `${percentage}%`;
            
            if (this.loadingProgress >= 100) {
                clearInterval(loadingInterval);
                this.percentageDisplay.style.opacity = '0';
                
                setTimeout(() => {
                    if (onComplete) onComplete();
                }, 500);
            }
        }, 30);
    }
}

const krakenEffect = new KrakenEffect();

// Add NFT minted dialog function
function showNFTDialog() {
    const dialog = document.createElement('div');
    dialog.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 255, 255, 0.1);
        border: 1px solid var(--neon-teal);
        color: var(--neon-teal);
        padding: 1rem 2rem;
        border-radius: 8px;
        font-family: 'Inter', sans-serif;
        backdrop-filter: blur(10px);
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s ease;
    `;
    dialog.textContent = 'Audio Data NFT Minted';
    document.body.appendChild(dialog);
    
    // Fade in
    requestAnimationFrame(() => dialog.style.opacity = '1');
    
    // Remove after 3 seconds
    setTimeout(() => {
        dialog.style.opacity = '0';
        setTimeout(() => dialog.remove(), 300);
    }, 3000);
}

// Add audio visualization function
function startAudioVisualization() {
    const audio = new Audio('audio/sample1.mp3');
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaElementSource(audio);
    
    source.connect(analyser);
    analyser.connect(audioContext.destination);
    analyser.fftSize = 2048;

    const container = document.createElement('div');
    container.className = 'audio-visualizer';
    document.body.appendChild(container);

    // Create a spherical energy field
    const particles = [];
    const numLayers = 6;
    const particlesPerLayer = 20;
    const floatingParticles = 45;

    // Center coordinates for better alignment
    const centerX = 0;
    const centerY = 0;

    // Create spherical layers with centered coordinates
    for (let layer = 0; layer < numLayers; layer++) {
        const layerRadius = 25 + layer * 15;
        for (let i = 0; i < particlesPerLayer; i++) {
            const particle = document.createElement('div');
            particle.className = 'tentacle-particle branch-particle';
            container.appendChild(particle);
            
            const phi = Math.acos(-1 + (2 * layer) / numLayers);
            const theta = Math.sqrt(particlesPerLayer * Math.PI) * i;
            
            particles.push({
                element: particle,
                theta,
                phi,
                radius: layerRadius,
                size: 1.4 - (layer / numLayers),
                phase: Math.random() * Math.PI * 2,
                speed: 0.5 + Math.random() * 0.5
            });
        }
    }

    // Create floating particles with centered coordinates
    for (let i = 0; i < floatingParticles; i++) {
        const particle = document.createElement('div');
        particle.className = 'tentacle-particle float-particle';
        container.appendChild(particle);
        
        const radius = Math.random() * 45;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        particles.push({
            element: particle,
            theta,
            phi,
            radius,
            speed: 0.2 + Math.random() * 0.2,
            size: 1.0 + Math.random() * 0.8,
            phase: Math.random() * Math.PI * 2
        });
    }

    setTimeout(() => {
        container.style.opacity = '1';
        audio.play();
    }, 300);

    let time = 0;
    function animate() {
        time += 0.016;
        
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(dataArray);

        const bassFreq = dataArray.slice(0, 10).reduce((a, b) => a + b, 0) / 2550;
        const midFreq = dataArray.slice(10, 100).reduce((a, b) => a + b, 0) / 22950;
        const highFreq = dataArray.slice(100, 200).reduce((a, b) => a + b, 0) / 25500;

        // Gentler rotation
        const rotationX = Math.sin(time * 0.5) * 0.1;
        const rotationY = Math.cos(time * 0.3) * 0.1;

        particles.forEach(particle => {
            // Update particle position with spherical coordinates
            const theta = particle.theta + time * particle.speed * (1 + bassFreq * 0.3);
            const phi = particle.phi + Math.sin(time + particle.phase) * 0.1;
            
            // Add audio-reactive radius variation
            const radiusVar = Math.sin(time * 2 + particle.phase) * (5 * midFreq);
            const radius = particle.radius * (1 + bassFreq * 0.2) + radiusVar;

            // Convert spherical to cartesian coordinates
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);

            // Apply rotation
            const rx = x * Math.cos(rotationX) - z * Math.sin(rotationX);
            const ry = y;
            const rz = x * Math.sin(rotationX) + z * Math.cos(rotationX);

            const finalX = rx * Math.cos(rotationY) - ry * Math.sin(rotationY);
            const finalY = rx * Math.sin(rotationY) + ry * Math.cos(rotationY);
            const finalZ = rz;

            particle.element.style.transform = 
                `translate3d(${finalX}px, ${finalY}px, ${finalZ}px) 
                 scale(${particle.size * (1 + highFreq * 0.3)})`;
            
            // Adjust opacity based on z-position for depth effect
            const depth = (finalZ + 40) / 80;
            particle.element.style.opacity = 
                (particle.element.classList.contains('branch-particle') ? 0.4 : 0.3) + 
                bassFreq * 0.6 * depth;
        });

        if (!audio.ended) requestAnimationFrame(animate);
        else {
            // Collapse sphere effect
            let collapse = 0;
            const fadeOut = setInterval(() => {
                collapse += 0.02;
                const scale = 1 - collapse;
                
                particles.forEach(particle => {
                    particle.element.style.transform += ` scale(${scale})`;
                    particle.element.style.opacity = Math.max(0, 1 - collapse * 2);
                });
                
                if (collapse >= 1) {
                    clearInterval(fadeOut);
                    particles.forEach(p => p.element.remove());
                    container.remove();
                }
            }, 16);
        }
    }

    animate();
}

function createTitle() {
    const title = document.createElement('div');
    title.className = 'ava-title';
    title.innerHTML = `
        <div class="ava-text">AVA</div>
        <div class="ava-subtitle">AI Voice Agents</div>
    `;
    document.body.appendChild(title);
}
</script>

<svg style="position: absolute; width: 0; height: 0;">
    <defs>
        <filter id="glow">
            <feGaussianBlur stdDeviation="1" result="coloredBlur"/>
            <feMerge>
                <feMergeNode in="coloredBlur"/>
                <feMergeNode in="SourceGraphic"/>
            </feMerge>
        </filter>
    </defs>
</svg>
</body>
</html>
